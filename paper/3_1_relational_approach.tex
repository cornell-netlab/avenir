\section{A Relational Approach}

A match-action table can be thought of in a similar way to a table in
a Relational Database. This observation was first made in a CoNeXT
2019 paper~\cite{Chiesa}. In this way a match-action table
$\apply{t, \vec k, \vec c, a}$ can be represented as a relation
$T = F_1 \times \cdots \times F_n \times A$ where
$F_i = \mathsf{dom}(k_i)$ and $c_j \in A$, then, a $t$-complete
configuration $g$ denotes a subset of $T$.

\subsection{Single-Table Programs}

To ground our investigation, lets first consider the simple situation
where both our logical and concrete programs are comprised of a single
table. So we have two table applications,
$\apply{t,\vec k, \vec c, a}$ and $\apply{s, \vec l, \vec d, b}$,
which we represent as relations of the form
\[T = F_1 \times \cdots \times F_n \times A\]
\[S = G_1 \times \cdots \times G_m \times B\] where $A$ and $B$ are
sets of actions, $F_i = \mathsf{dom}(k_i)$, $G_j = \mathsf{dom}(l_i)$,
$A = \vec c$ and $B = \vec d$, and with the functional dependencies
\[F_1, \ldots, F_n \to A\] \[G_1, \ldots, G_n \to B.\] We write $T$
and $S$ as functions as notational shorthand. We now build up the same
scaffolding of programs as for the full-program formulation.

\subsubsection{Single Table Verification}
First we define a problem called $\textsc{SingleVerif}(T_0, S_0)$,
which takes instantiations $T_0 \subset T$ and $S_0 \subset S$ and
determines whether
$\forall \pkt. \bracbb{T_0(\pi_{F_1,\ldots,F_n}(pkt))}\;\pkt =
\bracbb{S_0(\pi_{G_1,\ldots,G_n}(\pkt))}\; \pkt$ via the condition

\[\begin{array}c
    \multicolumn{1}{l}{\textsc{SingleVerif}(S_0,T_0) \triangleq}\\
    \displaystyle \quad \bigwedge_{\vec k, c \in T_0}\left(\vec k = \pi_{F_1,\ldots,F_n}(\pkt)\right) \Rightarrow wp(c,\pkt= \pkt')\\ \iff \\
    \displaystyle \quad \bigwedge_{\vec l, d \in S_0}\left(\vec l = \pi_{G_1,\ldots,G_m}(\pkt)\right) \Rightarrow wp(d, \pkt= \pkt')
  \end{array}
\]

\subsubsection{Instance Synthesis}

The next question we can ask is: given a single logical instantiation
$T_0$ can we construct a concrete instantiation $S_0$ that satisfies 
\textsc{SingleVerif}? Formally, we write
\[\textsc{SingleInstSynth}(T_0) \triangleq \exists
  S_0. \textsc{SingleVerif}(T_0, S_0)\]

\subsubsection{Mapping Synthesis}

We can lift this up to asking whether there is a function that will
produce, for an arbitrary $T_0$, an equivalent $S_0$, specifically, we write
\[\textsc{SingleMapSynth}() \triangleq \exists f. \; \forall T_0.\;
  \textsc{SingleVerif}(T_0, f(T_0))\]

\subsubsection{Decomposing Keys and Actions}

We can decompose the \textsc{SingleMapSynth} problem into two problems
\textsc{KeyMapSynth} and $\textsc{ActMapSynth}()$ respectively map the
actions and the keys. Luckily, \textsc{KeyMapSynth} has a very easy
intuition, they keys of the logical table must be a subset of the
concrete table:
\[\{F_1, \ldots, F_n\} \subseteq \{G_1, \ldots, G_m\}\]

Then, a solution to $\textsc{KeyMapSynth}()$ is the injection map which crosses the missing columns with the full set:
\[\displaystyle \iota (k_1, \ldots, k_n) = \Pi_{j=1}^m \begin{cases}
    \{k_i\}, & \exists i,  F_i = G_j \\
    G_j, & \mathit{otherwise}
    \end{cases}
\]

And a solution to $\textsc{ActMapSynth}(a)$ for $a \in A$ is a map
from $\alpha : A \to B$ such that the following holds:
\[\bigwedge_{a \in A} \forall \pkt,\pkt'.\; \wp(a, \pkt = \pkt')
  \Leftrightarrow \wp(\alpha(a), \pkt = \pkt')\] 

\[\bigwedge_{a \in A} \bracbb{a} = \bracbb{\alpha(a)}\]

We conjecture that every solution $f$ to $\textsc{SingleMapSynth}()$
can be captured by the pair $(\iota, \alpha) : T \to S$ which form
solutions to $\textsc{KeyMapSynth}()$ and $\textsc{ActMapSynth}()$
respectively.





\subsubsection{Single-Table Programs with Functional Dependencies}

We can also consider variants of the mapping synthesis problem that
incorporate functional dependencies on the logical and real tables. We
call this problem $\textsc{SingleMapSynthFD}()$ which takes as given
sets of functional dependencies $D_S$ and $D_T$, and requires that any
solution $(\alpha, \iota)$ must obey the following property in
addition to satisfying $\textsc{KeyMapSynth}$ and
$\textsc{ActMapSynth}$:
\[F_1,\ldots, F_n  \longrightarrow \alpha(A) \in D_S \Rightarrow
  F_1,\ldots, F_n \longrightarrow A \in D_T\]


\[\alpha_A(D_S) \subseteq D_T\]

We can encode this in Z3 by statically computing all tuples in $D_S^+$
and in $D_T^+$ and checking whether $D_T^+ \subseteq D_S^+$.

\subsection{Composing Tables}

The approach detailed above generalizes to full tables so long as we
can compress a full program into a single match-action table. In some
cases, this is quite easy--for example, when the tables test and
modify disjoint sets of variables. In Figure~\ref{fig:easy-example},
we see that the composed table has the cross product of keys, and the
cross product of actions. We only need to constrain the new table with
the functional dependencies $\texttt{src} \longrightarrow X$ and
$\texttt{dst} \longrightarrow Y$, so that we can properly convert
every instance of each relation to the other. However, it becomes much
more difficult when we have to consider relationships between tables.

\begin{figure}[ptb]
  \begin{minipage}{0.32\columnwidth}
  \[\begin{array}{c}
      (\texttt{src}, X); (\texttt{dst}, Y)
      \\ = \\
      (\langle\texttt{src,dst}\rangle, X, Y)
    \end{array} \]
\end{minipage} \hfill \vline \hfill \begin{minipage}{0.66\columnwidth}
  \[\begin{array}l
      X = \{x:=v \mid v = 1,2,3,4\}\\
      Y = \{y:=v \mid v = 1,2,3,4
    \end{array}\]
  \hrule
  \[\begin{array}{cc}
      \texttt{src} \longrightarrow X
      &\texttt{dst} \longrightarrow Y
    \end{array} \]
\end{minipage}
\caption{Disjoint Cross Product}
  \label{fig:cross-product-ex}
\end{figure}

\begin{figure}[ptb]
  \begin{minipage}{.33\columnwidth}
  \[\begin{array}{c}
      (\texttt{src}, X);
      (\texttt{x}, D)
      \\ = \\
      (\texttt{src}, X, D)
    \end{array}\]
\end{minipage}\hfill\vrule\hfill\begin{minipage}{.66\columnwidth}
  \[\begin{array}l
      X = \{x:=v \mid v = 1,2,3,4\}\\
      D = \{\texttt{dst} := v \mid v = 101,102,103,104\} \\
    \end{array}
  \]
  \hrule
  \[\texttt{src}\longrightarrow XD\]
\end{minipage}

\caption{Dependency Example.We have the constraint that
  $X \longrightarrow \texttt{x}$, so candidate key for the table is
  simply \texttt{src}.}
  \label{fig:dependency-ex}
\end{figure}

A common programming pattern is for one table to set a piece of
metadata and then use that value as a key later in the program. For
instance, consider Figure~\ref{fig:dependency-ex}. Notice that the
value of \texttt{x} is completely determined by the contents of the
previous table, which means that the only key we need in the composite
table is \texttt{src}. 

\begin{figure}
  \begin{minipage}{0.33\columnwidth}
  \[\begin{array}c
      (\texttt{src}, X');(\texttt{x}_1,D)
      \\ = \\
      (\langle\texttt{src},\texttt{x}_0\rangle, X', D)
    \end{array}
  \]
\end{minipage}\hfill \vline \hfill\begin{minipage}{0.66\columnwidth}
  \[\begin{array}{l}
      X = \{\texttt{x}_1:=1, \texttt{x}_1:=\texttt{x}_0\}\\
      D = \{\texttt{dst} := v \mid v = 101,102,103,104\}
    \end{array}
  \]
  \hrule\[\begin{array}{cc}
      \texttt{src} \to X'
      & \bracbb{X'}(\texttt{x}_0).\texttt{x}_1 \to D
    \end{array}\]
\end{minipage}
  \caption{Partial Dependency Example}
  \label{fig:partial-depend-ex}      
\end{figure}

Unfortunately, the complexity doesn't stop there. If a table only
partially determines the value of a variable that is uses as a keys in
the next table, then the relationship is tricky. Consider the two
tables in Figure~\ref{fig:partial-depend-ex}, It doesn't hold that
$X' \longrightarrow \texttt{x}$ (as in
Figure~\ref{fig:dependency-ex}). But, the trivial functional
constraint $\texttt{x}_0X' \longrightarrow \texttt{x}_1$
holds, where $\texttt{x}_0$ is the value of $\texttt{x}_1$ before
executing any of the actions in $X'$ and $\texttt{x}_1$ is the value
after -- the one used in the key of the second table.

As we would have done in~\ref{fig:cross-product-ex}, we would like to
enforce the functional dependency $\texttt{x}_1 \longrightarrow D$;
however, $x_1$ can't be a key in the composed table, because we need
the match to occur before we execute $X'$. However, we do have the
information to compute $x_1$ in the table -- we require that
$\bracbb{X'}(\texttt{x}_0).\texttt{x}_1\longrightarrow D$, i.e. the
values of $\texttt{x}_1$ in the image of the actions in $A$ over
packets where the values of $\texttt{x}_0$ are known. To see why we
need this, consider the following table entries
\[
  \begin{array}{c|c|c|c}
    \texttt{src} & \texttt{x}_0 & X' & D\\ \hline
    101 & 99 & \texttt{x}_1 := 1 & \texttt{dst} := 104 \\
    101 & \vdots & \texttt{x}_1 := 1 & \texttt{dst} := 104 \\
    102 & 1 & \texttt{x}_1 := \texttt{x}_0 & \texttt{dst} := 101 \\
    102 & \vdots & \texttt{x}_1 := \texttt{x}_0 & \texttt{dst} := 101 \\
  \end{array}
\]

These rules satisfy the requirement that
$\texttt{src}\longrightarrow X'$, so we can losslessly add rules to
the first table, however, we have a rule-conflict when we try and add
rules to the second table. Notice that for each rule, $x_1 = 1$, which
means the keys in the second table need to be the same, but they each
select different actions!
\[
  \begin{array}{c|c}
    \texttt{src} & X'\\ \hline
    101 & \texttt{x}_1 := 1  \\
    102 & \texttt{x}_1 := x_0 \\
  \end{array}\enspace ; \enspace
  \begin{array}{c|c}
    \texttt{x}_1 & D\\ \hline
    1 & \texttt{dst} := 104 \\
    1 & \texttt{dst} := 101 \\
    \vdots & \texttt{dst} := 101 \\
  \end{array}  
\]

However, if we unpack the definition of the constraint
$\bracbb{X'}(\texttt{x}_0).\texttt{x}_1 \to D$, we get
\[\pi_{\texttt{x}_1}\left(\bigcup_{a \in X, x \in
      \texttt{x}_0,\pkt} \bracbb{a}\; pkt[\texttt{x}_0 \mapsto x]
  \right) \longrightarrow D.\] Unfolding definitions again, this says
that for any relation $R$ implementing the that populates the table
$(\langle\texttt{src},\texttt{x}_0\rangle, X', D)$ it must be that for
rows $\rho, \rho' \in R$, then $\rho.D = \rho.D$ holds if the
following condition holds
\[\forall \pkt. \left(\bracbb{\rho.a}\; \pkt[\texttt{x}_0 \mapsto
    \rho.x_0 ]\right).x_1 =
  \left(\bracbb{\rho'.a}\;\pkt[\texttt{x}_0\mapsto \rho.x_0
    ]\right).x_1\]

which prohibits the key-conflict in the second table
$(\texttt{x}_1,D)$. Specifically, since
\[\left(\bracbb{x_1:=1} \{x_0 \mapsto 99\}\right).x_1 = 1 =
  \left(\bracbb{x_1:=x_0} \{x_0 \mapsto 1\}\right).x_1\] and
$\texttt{dst} := 101 \neq \texttt{dst} := 104$. Thus, this condition
prohibits this combination of rules in
$(\texttt{src}, \texttt{x}_0, X', D)$.

\begin{figure}[tpb]
  \[\begin{array}{c>{\triangleq}cl}
      \delta(x := e,v) && \begin{cases}
        \fvs(e) &x = v\\
        \{v\} & \textit{otherwise} \end{cases} \\
      \delta(c;c', v) && \left\{v'' \mid v' \in \delta(c, v), v'' \in \delta(c', v')\right\} \\
      \delta(c\angel c', v) && \delta (c, v) \cup \delta(c', v) \\
      \delta(\assert b, v) && \fvs(b) \cup \{v\} \\
      \delta(\assume b, v) && \fvs(b) \cup \{v\} \\\\
      \Delta(A, V) && \displaystyle\bigcup_{a\in A,v \in V}\delta(a,v)
    \end{array}\]
  \caption{Dominating Sets}
  \label{fig:delta }
\end{figure}

As a helper function, we define the dominating set $\Delta(A,G)$ to be
the (smallest) set of variables required to determine the values of $G$
after running $A$. We characterize $\Delta(A,G)$ in two properties.

\begin{lemma}[Defined Free Variables Defines Expressions]
  \label{lem:def-fvs-expr}
  For an expression $e$, with
  $\{\texttt{x}_1, \ldots, \texttt{x}_n\} \in \fvs(e)$, and
  $v_i \in \texttt{x}_i$ for $i \in [n]$,
  $\bracbb{e}~(\cdot[\vec{\texttt{x}} \mapsto \vec{v}])$ is defined.
\end{lemma}

\begin{proof}
  Proceed by induction on the structure of $e$.  \todo[inline]{the
    proof!}.
\end{proof}

\begin{lemma}[$\delta$-Domination]
  \label{lem:delta-dom}
  Given a deterministic, total command $a$, and a variable
  $\texttt{x} \in \Var$, if
  $\{\texttt{x}_1, \ldots, \texttt{x}_n\} = \delta(a,v)$ and
  $v_i \in \texttt{x}_i$, then for every $\pkt$ and $\pkt'$,
  $\bracbb{a}~\left(\pkt[\vec{\texttt{x}} \mapsto \vec v]\right)
  = \bracbb{a}~\left(\pkt'[\vec{\texttt{x}} \mapsto \vec v]\right)$
  is defined.
\end{lemma}

\begin{proof}
  Proceed by induction on the structure of $a$, leaving
  $\texttt{x}$, $\pkt$, and $\pkt'$ free.
  \begin{enumerate}[align=left]
  \item[($\SKIP$)] Let $\texttt{x} \in \Var$, Desugar
    $\SKIP = \assume \TRUE$. Since $\fvs(\TRUE) = {}$, then
    $\delta(\assume\TRUE, \texttt{x}) = \{\texttt{x}\}$. Let $\pkt$
    and $\pkt'$ be packets. Let $v_x \in \texttt{x}$. Notice that
    $\bracbb{\assume\TRUE} = \lambda x.x$, so calculate
    $(\pkt[\texttt{x} \mapsto v_x]).\texttt{x} = v_x=
    (\pkt'[\texttt{x} \mapsto v_x]).\texttt{x}$.
  \item[($\nop$)] \textit{sim.}
  \item[$(\texttt{y}:=e)$] Let $\texttt{x} \in
    \Var$. There are two cases: $x = v$ or $x \neq v$.  If $\texttt{y}
    = \texttt{x}$ then $\delta(a,\texttt{x}) =
    \fvs(e)$. By Lemma~\ref{lem:def-fvs-expr},
    $\bracbb{e}~\pkt[\fvs(e) \mapsto \vec v] = u =
    \bracbb{e}~\pkt'[\fvs(e) \mapsto \vec
    v]$, so $\bracbb{\texttt{x}:=e}~\pkt = \pkt[\texttt{x} \mapsto
    u].\texttt{x} = u = \pkt'[\texttt{x} \mapsto u] =
    \bracbb{\texttt{x}:=e}~\pkt'$.

    If $\texttt{y} \neq \texttt{x}$, Then
    $\delta(a,v) = \{\texttt{x}\}$. Let
    $\bracbb{e}~\pkt[\texttt{x} \mapsto v] = u$ and
    $\bracbb{e}~\pkt[\texttt{x} \mapsto v] = u'$. Then
    \[\begin{array}l
        \left(\bracbb{x:=e}~\pkt[\texttt{x} \mapsto v]\right).\texttt{x}\\
        = \pkt[\texttt{x} \mapsto v,\texttt{y} \mapsto u].\texttt{x} \\
        = v \\
        = \pkt'[\texttt{x}\mapsto v, \texttt{y}\mapsto u']/\texttt{x} \\
        = \left(\bracbb{x:=e}~\pkt'[\texttt{x} \mapsto v]\right).\texttt{x}
      \end{array}\]

  \item[$(\ifte b {c_1} {c_2})$] Desugar
    \[\ifte b {c_1} {c_2} \triangleq\assume b; c_1 \angel \assume{\neg
        b}; c_2\] Then let
    $D = \delta\left(\left(\assume b; c_1 \angel \assume{\neg b};
        c_2\right),v\right) = \fvs(b) \cup \delta(c_1,v) \cup
    \delta(c_2,v)$. Let $\vec{v^b}$ be the values corresponding to
    fields in $\fvs(b)$, $\vec{v^1}$ be the values corresponding to
    the fields in $\delta(c_1,\texttt{x})$ and let $\vec{v^2}$ be the
    values corresponding to the fields in
    $\delta(c_2,\texttt{x})$. Let $\pkt$ and $\pkt'$ be
    packets. Notice that we can commute our assignments to any of the
    variables in $\delta(c_1,\texttt{x})$, $\delta(c_2,\texttt{x})$,
    or $\fvs(b)$, because, as projections of the same map, either
    they're idempotent or distinct. Then, we know, by
    Lemma~\ref{lem:def-fvs-expr}, that
    \[\begin{array}l
        \bracbb{b}~\pkt[\delta(c_1,\texttt{x})\delta(c_2,\texttt{x})
        \mapsto \vec{v^1}][\fvs(b) \mapsto \vec{v^b}] \\
        = t\\
        =  \bracbb{b}~\pkt'[\fvs(b) \mapsto \vec{v^b}]
      \end{array}\]
    Note $t \in \mathbf 2$. We'll show the case where $t = \TRUE$, the
    alternate case is symmetric.

    Since $t = \TRUE$, we execute
    \[\begin{array}l
        \left(\bracbb{c_1}~\pkt[\delta(c_1,\texttt{x}),\delta(c_2,\texttt{x})
        \mapsto \vec{v^1},\vec{v^2}][\fvs(b) \mapsto \vec{v^b}]\right).\texttt{x}
        \\ =  \left(\bracbb{c_1}~\pkt[\fvs(b),\delta(c_2,\texttt{x})
        \mapsto \vec{v^b}, \vec{v^2}][\delta(c_1,\texttt{x}) \mapsto \vec{v^1}]\right).\texttt{x}
        \\ = \left(\bracbb{c_1}~\pkt'[\fvs(b),\delta(c_2,\texttt{x})
        \mapsto \vec{v^b}, \vec{v^2}][\delta(c_1,\texttt{x}) \mapsto \vec{v^1}]\right).\texttt{x}
        \\ \multicolumn 1 r {\text{by IH}(c_1)}
      \end{array}
    \]
  \item[$(c;c')$] Let $\pkt, \pkt'$ be packets.
    Let
    \begin{align*}
      \pkt_z &= \pkt[\texttt{z} \mapsto v_z \mid \texttt z \in \delta(c, \texttt y), \texttt y \in \delta(c', \texttt{x})] \\
      \pkt'_z &= \pkt'[\texttt{z} \mapsto v_z\mid \texttt z \in \delta(c, \texttt y), \texttt y \in \delta(c', \texttt{x})]\\
      \pkt_c &= \bracbb{c}~\pkt_z \\
      \pkt'_c &= \bracbb{c}~\pkt'_z 
    \end{align*}
    Then by IH$(c)$, $\forall y \in \delta(c', \texttt{x})$,
    \[\pkt_c.\texttt{y} = v_y = \pkt'_c.\texttt{y}\]
    which gives us the facts that
    \begin{align*}
      \pkt_c &= \pkt_c[\texttt{y} \mapsto v_y \mid y \in \delta(c', \texttt{x})]\\
      \pkt'_c &= \pkt'_c[\texttt{y} \mapsto v_y \mid y \in \delta(c', \texttt{x})]
    \end{align*}
    So by IH$(c')$ conclude that 
    \[(\bracbb{c'}~\pkt_c).\texttt{x} = (\bracbb{c'}~\pkt'_c).\texttt{x}\]
  \end{enumerate}
\end{proof}  

\begin{proposition}[$\Delta$-Domination]
  \label{prop:Delta-dom}
  Given a set of deterministic, total commands $A$, and a set of keys
  $G \subset \Var$, then for $\vec{v} \in \vec{V}$ for
  $\{V_1, \ldots, V_n\} = \Delta(A,G)$, and every $\texttt{g} \in G$, for every
  $\pkt, \pkt \in \Pkt$,
  $\bracbb{A}~\left(\pkt[\vec V \mapsto \vec v]\right).\texttt{g} =
  \bracbb{A}~\left(\pkt'[\vec V \mapsto \vec v]\right).\texttt{g}$.
\end{proposition}

\begin{proof}
  By defintion
  \begin{align*}
    \bracbb{A}~\left(\pkt[\vec V \mapsto \vec v]\right) &= \{\bracbb{a}~\pkt[\vec V \mapsto \vec v] | a \in A\} \\
    \bracbb{A}~\left(\pkt'[\vec V \mapsto \vec v]\right) &= \{\bracbb{a}~\pkt'[\vec V \mapsto \vec v] | a \in A\} \\
  \end{align*}

  So we only need to show for every $a \in A$, that
  $\bracbb{a}~\pkt[\vec V \mapsto \vec v] = \bracbb{a}~\pkt'[\vec V
  \mapsto \vec v] $.

  Let $a \in A$. By definition, since $a \in A$ and
  $\texttt{g} \in G$, observe that
  $\delta(a,\texttt{g}) \in \Delta(A,G)$. So, we can partition
  $\vec V$ and $\vec v$ into $(\vec{U}, \vec W)$ and
  $(\vec u, \vec w)$ respectively, where $u_i \in U_i$ and
  $U_i \in \delta(a,g)$ and $w_i \in W_i$ and $W_i \not\in
  \delta(a,g)$. Then, since $\vec{U}$ and $\vec W$ are disjoint,
  \begin{align*}
    \bracbb{a}~\pkt[\vec V \mapsto \vec v] &= \bracbb{a}~\pkt[W\mapsto\vec{w}][U \mapsto\vec{u}]\\
    \bracbb{a}~\pkt'[\vec V \mapsto \vec v] &= \bracbb{a}~\pkt'[W\mapsto\vec{w}][U \mapsto\vec{u}]
  \end{align*}

  The result follows by Lemma~\ref{lem:delta-dom}.
  
\end{proof}


\begin{figure}[tpb]
  \[\begin{array}{ccl}
      \compose{(F,A)}{(G,B)}
      & \triangleq
      & ((F\times\Delta(G,A), A\times B),\\
      &&\{F \longrightarrow A, \bracbb{A}(\Delta(A,G)).G \to B \})\\[.2em]
  %   \end{array}\]
  % \[\begin{array}{lcl}
      \relcomp{s}{t}{S}{T}
      & \triangleq
      % & \{(\keys\sigma,d,\acts\sigma,\acts\tau)\\
      % && \hspace{.5em}
      %    \mid \sigma \in S, \tau \in T, d \in D = \Delta(\acts\sigma, \keys\tau),\\
      % && \hspace{1em}
      %    \keys\tau \in \bracbb{\textsf{reduce}~(;)~\acts\sigma}~[D \mapsto d]
      %    \}\\[.2em]
      & \{(\sigma.F,d,\sigma.A,\tau.B) \\
      && \hspace{.5em}
         \mid \sigma \in S, \tau \in T, (F,A) = s, (G,B) = t \\
      && \hspace{1em}
         d \in D = \Delta(A, G), Q = D \cap F\\
      && \hspace{1em}
         \tau.G = \bracbb{\sigma.A}~[D \mapsto d]\\
      && \hspace{1em}
         d.Q = \sigma.Q
         \}\\        
      \decomp s t R
      & \triangleq
      & (\{(\rho.F,\rho.A) \mid \rho \in R, s = (F,A)\} \\
      && , \{(p.G, \rho.B) \\
      && \hspace{.5em} \mid \rho \in R, (F,A) = s, (G,B) = t, \\
      && \hspace{1em}
         D = \Delta(A,G), Q = D \cap F, \\
      && \hspace{1em}
         p = \bracbb{\rho.A}~[D \to \rho.D],\\
      && \hspace{1em} d.Q = \sigma.Q
         \} )
    \end{array}
  \]  
  \caption{Table Composition ($\compose{s}{t}$), relation
    composition ($\relcomp{s}{t}{S}{T}$), and relation
    decomposition ($\decomp{s}{t}{R}$).}
  \label{fig:compose-tables}
\end{figure}

Now we can use these intuitions to write down a composition operator
for tables, and conversions between the entries. In
Figure~\ref{fig:compose-tables}, we define table composition
$(r,\Phi_r) = s \circ t$, relation composition for those tables
$R = S \bowtie_{s,t} T$, and then relation decomposition,
$\pi_{s,t}(R) = (S,T)$. When the context is obvious, we'll abbreviate
$\fst(\pi_{s,t}(R))$ by $\pi_{s}(R)$, and $\snd(\pi_{s,t}(R))$ by
$\pi_t(R)$. We want to prove that these operators commute.

\begin{proposition}
  \label{prop:join-proj}
  Given two tables $s = (F,A)$ and $t = (G,B)$, with
  $(r, \Phi_r) = s \circ t$. For every relation $R$ populating $r$ and
  respecting $\Phi_r$, if $\pi_{s,t}(R) = (S,T)$, then
  $S \bowtie_{s,t} T = R$.
\end{proposition}

\begin{proof}
  Let $R$ be a relation populating $r = (H,C)$ and respecting $\Phi_r$, show
  that $\pi_s(R) \bowtie_{s,t} \pi_t(R) = R$. Show each direction
  separately.
  \begin{enumerate}[align=left]
  \item[$(\subseteq)$] Let $\rho \in \pi_s(R) \bowtie_{s,t} \pi_t(R)$,
    to show that $\rho \in R$. Then, we know that
    \[\begin{array}l
        \rho = (\sigma.F, d, \sigma.A, \tau.B)\\
        \text{for some } \sigma \in \pi_s(R)\\
        \phantom{\text{for some }}\tau \in \pi_t(R)\\
        \phantom{\text{for some }}d \in \Delta(A, G), Q = \Delta(A,G) \cap F\\
        \text{such that } \tau.G = \bracbb{\sigma.A}~[\Delta(A,G) \mapsto d] \\
        \phantom{\text{such that }} d.Q = \sigma.Q
      \end{array} \]

    Further, we know that
    \[\begin{array}l
        \sigma = (\rho_s.F, \rho_s.A)\\
        \text{for some } \rho_s \in R\\
      \end{array}
    \]
    and
    \[\begin{array}l  
        \tau = (g, \rho_t.B) \\
        \text{such that } g = (\bracbb{\rho_t.A}~[\Delta(A,G) \mapsto \rho_t.\Delta(A,G)]).G \\
        \phantom{\text{such that }}\rho_t.\Delta(A,G).Q = \rho_t.F.Q
      \end{array}\]

    Composing these definitions, we get that
    \[\begin{array}l
        \rho = (\rho_s.F, d, \rho_s.A, \rho_t.B) \\
        \text{where } d \in \Delta(A, G)\\
        \phantom{\text{where }} g = (\bracbb{\rho_s.A}~[\Delta(A,G) \mapsto d]).G\\
        \phantom{\text{where } g} = (\bracbb{\rho_t.A}~[\Delta(A,G) \mapsto \rho_t.\Delta(A,G)]).G \\
        \phantom{\text{where }} d.Q = \rho_s.F.Q \\
        \phantom{\text{where }} \rho_t.\Delta(A,G).Q = \rho_t.F.Q 
      \end{array}\]
    
  \end{enumerate}

  Now, because of the constraint $\bracbb{A}(\Delta(A,G)).G \to B$, we
  know that $\rho_t.B = \rho_s.B$, So we want to show
  that \[(\rho_s.F, d, \rho_s.A, \rho_s.B) \in R\]

  Since $R$ is total, and $F \longrightarrow A$, we know that there is
  some $(\rho_s.F, d, \rho_s.A, b) \in R$. It is sufficient to show
  that $b = \rho_s.B$.  The facts that
  $g = (\bracbb{\rho_s.A}~[\Delta(A,G) \mapsto d]).G =
  (\bracbb{\rho_t.A}~[\Delta(A,G) \mapsto \rho_t.\Delta(A,G)]).G$, and
  $\rho_t \in R$, combine with the constraint
  $\bracbb{A}(\Delta(A,G)).G \to B$ to prove $b = \rho_s.B$, and we're
  done. \hfill \checkmark

\item[$(\supseteq)$] Let $\rho \in R$, subject to $\Phi_r$, to show
  that $\rho \in \pi_s(R) \bowtie_{s,t} \pi_t(R)$.

  We know that $(\rho.F, \rho.A) \in \pi_s(R)$, and further
  \[(\bracbb{\rho.A}[\Delta(A,G) \mapsto \rho.\Delta(A,G)],\rho.B) \in
    \pi_t(R)\]
  and \[\rho.F.Q = \rho.\Delta(A,G).Q.\]

  Then, by definition
  $(\rho.F, d, \rho.A, \rho.B) \in \pi_s(R) \bowtie_{s,t} \pi_t(R)$ when
  \[\bracbb{\rho.A}[\Delta(A,G) \mapsto \rho.\Delta(A,G)]
    = \bracbb{\rho.A}[\Delta(A,G) \mapsto d]\] and \[\rho.F.Q = d.Q.\]
  Since this is the case for $d = \rho.\Delta(A,G)$, conclude
  \[(\rho.F, \rho.\Delta(A,G), \rho.A, \rho.B) \in \pi_s(R)
    \bowtie_{s,t} \pi_t(R).\]
  \mbox{} \hfill \checkmark\\\mbox{}
\end{proof}

\begin{proposition}
  \label{prop:proj-join}
  Given two tables $s = (F,A)$ and $t = (G,B)$ with
  $(r, \Phi_r) = s \circ t$. For every relation $S$ populating $s$ and
  $T$ populating $t$, then $\pi_{s,t}(S \bowtie_{s,t} T) = (S,T)$.
\end{proposition}

\begin{proof}
  Let $S$ be a relation populating $s$ and $T$ be a relation
  populating $t$, to show that show that
  $ \pi_{s,t}(S \bowtie_{s,t}T) = (S,T)$. Show each containment
  separately:
  \begin{enumerate}[align=left]
  \item[$(\subseteq)$] Let $\sigma \in \pi_s(S \bowtie_{s,t} T)$ and
    $\tau \in \pi_t(S \bowtie_{s,t} T)$, to show that $\sigma \in S$
    and $\tau \in T$.

    Now show that $\sigma \in S$ and $\tau \in T$. We know that there is a $\rho \in S \bowtie_{s,t} T$ such that
    \[\tau = (\bracbb{\rho.A}[\Delta.(A,G) \mapsto \rho.\Delta(A,G)],
      \rho.B),\] and \[\rho.F.Q = \rho.\Delta(A,G).Q.\] By definition,
    there are $\sigma' \in S$ and $\tau' \in T$ such that
    $(\rho.F,\rho.A) = \sigma'$, and
    $\tau' = (\bracbb{\rho.A}[\Delta.(A,G) \mapsto \rho.\Delta(A,G)],
    \rho.B)$. Conclude that $\tau = \tau'$ and $\sigma =
    \sigma'$. \hfill \checkmark

  \item[$(\supseteq)$] Let $\sigma \in S$ and $\tau \in T$, to show
    that $\sigma \in \pi_s(S \bowtie_{s,t}T)$, and
    $\tau \in \pi_t(S \bowtie_{s,t} T)$.  Then we know that there is
    $\rho \in S\bowtie_{s,t}T$ such that $\rho.FA = \sigma$,
    $\rho.B = \tau.B$, and
    $\tau.G = \bracbb{\rho.A}[\Delta(A,G) \mapsto \rho.\Delta(A,G)]$
    with $\rho.F.Q = \rho.\Delta(A,G).Q$.  Finally, we have
    $\sigma' \in \pi_s(S \bowtie_{s,t}T)$ and
    $\tau' \in \pi_t(S \bowtie_{s,t} T)$ such that
    $\sigma' = \rho.FA$, $\tau'.B = \tau.B$, and
    $\tau'.\Delta(A,G) = \bracbb{\rho.A}~[\Delta(A,G) \mapsto
    \rho.\Delta(A,G)]$. Conclude that $\sigma = \sigma'$ and
    $\tau = \tau'$. \hfill \checkmark
  \end{enumerate}
\end{proof}

\begin{theorem}[Composition Functional Equivalence]
  \label{thm:comp-func-equiv}
  Given two tables $s = (F,A)$ and $t = (G,B)$ with
  $(r, \Phi_r) = s \circ t$. For every relation $S$ populating $s$ and
  $T$ populating $t$, $\bracbb{S;T} = \bracbb{S\bowtie_{s,t}T}$.
\end{theorem}

\begin{proof}
  Let $S$ be a relation populating $s$ and let $T$ be a relation
  populating $t$.
  %
  Let $\pkt$ be an aribtrary packet. Then, since $S$ is total, there
  is some rule $\sigma \in S$ such that \[\pkt.F = \sigma.F.\] Further, we
  know that we will execute actions $\sigma.A$, to get
  \[\pkt' = \bracbb{\sigma.A}~\pkt.\] Now, since $T$ is total, we know
  that there is some $\tau \in T$ such that \[\pkt'.G = \tau.G.\]
  Further, our final packet is \[\pkt'' = \bracbb{\tau.B}~\pkt'.\]

  By definition the following set of rules $R$ is a subset of $S \bowtie_{s,t}T$:
  \[\begin{array}{l}
      R  = \bigg\{\rho \in S \bowtie_{s,t} T~~\big|\\
      \qquad\quad \rho.F = \sigma.F = \pkt.F\\
      \qquad\quad \rho.A = \sigma.A \\
      \qquad\quad \tau.B = \rho.B \\
      \qquad\quad (\bracbb{\sigma.A}[\Delta(A,G) \mapsto \rho.\Delta(A,G)]).G =\tau.G \bigg\}
    \end{array}\]

  Since $(\bracbb{\sigma.A}~\pkt).G = \tau.G$, then by
  Proposition~\ref{prop:Delta-dom} there is some $\rho \in R$ such
  that $\pkt.F = \rho.F$ and $\pkt.\Delta(A,G) =
  \rho.\Delta(A,G)$. Since $\rho.A = \sigma.A$ and
  $\rho.B = \sigma.B$, conclude that
  \[\bracbb{\rho.B}\left(\bracbb{\rho.A}~\pkt\right) = \pkt''.\]
\end{proof}


\begin{theorem}[Decomposition Functional Equivalence]
  \label{thm:decomp-func-equiv}
  Given two tables $s = (F,A)$ and $t = (G,B)$ with
  $(r, \Phi_r) = s \circ t$. For every relation $R$ populating $r$, 
  $\bracbb{\pi_s(R);\pi_t(R)} = \bracbb{R}$.
\end{theorem}

\begin{proof}
  Let $R$ be a relation populating $R$. By
  Proposition~\ref{prop:proj-join},
  $R = \pi_s(R)\bowtie_{s,t}\pi_t(R)$. The result follows by
  Theorem~\ref{thm:comp-func-equiv} setting $S = \pi_s(T)$ and
  $T=\pi_t(R)$.
\end{proof}

\subsection{An Algorithm for Instance Synthesis}

First, we present the online version of the algorithm, which, for a
given logical table instantiation, produces a physical table
instantiation that implements the same functionality.

Formally, given one big logical table $s = (F, \vec A)$ with FDs $\Phi$ and
one big physical table $t = (G, \vec B)$ with FDs $\Psi$, and a relation
$S$ populating $s$ such that $S \models \Phi$, we want to compute a
relation $T$ populating $t$ such that $\bracbb S = \bracbb T$, and $T
\models \Psi$. 

Assume that $F$ is a candidate key for the table $s$. This means that
for every $X$ such that $X \longrightarrow F\vec A$,
$F \longrightarrow X$, and $|F| \leq |X|$. If it isn't, we can,
equivalently replace $F$ with a candidate key, since the other values
of $F$ will be determined by the candidate key.

Now, recall that the keys $F$ will be mapped injectively into $G$ via
a map $\kappa : F \to G$. In other words, given a rule $\sigma \in S$,
we will create an equivalent rule $\tau$ in $T$ such that if
$\sigma.\texttt{x} \in F \cap G$, then
$\tau.\texttt{x} = \sigma.\texttt{x}$, otherwise
$\tau.\texttt{x} = *$.

Next, we map the actions. Each action sequence $\vec a$ has a
candidate set $\hat\alpha(\vec a) \subseteq \vec B$ of physical
actions, such that $\vec b \in \hat\alpha(\vec a)$ iff
$\bracbb{b_1;\ldots;b_m} = \bracbb{a_1;\ldots;b_n}$. Now, there is a
set of candidate relations $T_1,\ldots, T_k$ created by injecting the
keys of $S$ into $t$, and selecting a candidate $\vec b$ from
$\hat \alpha(\sigma.\vec A)$ for each $\sigma \in S$. By construction,
for every $T_i$, $\bracbb{T_i} = \bracbb{S}$. We search through these
candidate solutions $T_i$ until one of them satisfies $\Psi$.

In the common case, we expect $|\hat\alpha(\vec a)|$ to be close to 1,
so the search space is small. Further, we can precompute the candidate
sets $\hat \alpha(\vec a)$ for every possible action so that all we
need check at runtime are the functional dependencies.

% \subsection{The Algorithm}

% \begin{figure}[tpbh]
%   \[
%     p \preceq q \overset{\triangle}{\iff}
%     p =_{\nabla(q)} q 
%   \]
%   \[p =_{S} q \overset\triangleq\iff \forall \pkt, \pi_S(\bracbb{p}~\pkt) = \pi_S(\bracbb{q}~\pkt)\]
%   \[\nabla(p) \triangleq \{\texttt x \in
%     \mathsf{Var} \mid \exists \pkt.~\pkt.\texttt x \neq
%     (\bracbb{p}~\pkt.\texttt x) \}\]
%   \caption{A specificity order on programs}
%   \label{fig:order}
% \end{figure}

% The goal is, given two sequences of tables $t_1;\cdots;t_n$ (logical)
% and $s_1;\cdots;s_m$ (physical) compute a function
% $f(T_1,\ldots,T_n) = (S_1,\ldots,S_m)$, where $T_i$ populates $t_i$,
% and $S_i$ populates $s_i$ such that
% $\bracbb{T_1;\cdots;T_n} = \bracbb{S_1;\cdots;S_m}$. Heres how we do
% it:
% \begin{itemize}
% \item Compute
%   \begin{align*}
%     ((F,A),\Phi_t) &= t_1 \circ \cdots \circ t_n\\
%     ((G,B),\Phi_s) &= s_1 \circ \cdots \circ s_m
%   \end{align*}
% \item Notice that $A = A_1\times \cdots \times A_k $ and
%   $B = B_1 \times \cdots \times B_l$.

% \item For each $A_i$ and each $a \in A_i$, define
%   \[\mathcal B_{a,k} \subseteq B_{1}\times \cdots \times B_{l},\]
%   Initialize $\mathcal B_{a,i}$ to $\emptyset$. Add every $\vec b$ to
%   $\mathcal B_{a,k}$ such that each $b_j = \Angel C_j$ where
%   $C_j \subseteq B_{a,k}$ and $\emptyset \neq C_j$, and
%   $b_1; \cdots ; b_l \preceq a$.

% \item Compute attribute substitutions. For each $A_i$, $a \in A_i$,
%   and $\vec b \in \mathcal B_{a,i}$, then add $A_i \mapsto B_j$ to
%   $\sigma(i,a,b)$, for each $b_j \neq \Angel B_j$.

%   Given a mapping $f_i: A_i \to B$, define $\sigma(f_i)$ to be
%   $\{A_i \mapsto B_j \mid b_j \neq B_j, \vec b \in f(A_i)\}$.

%   As syntactic sugar for $\sigma(f_1)~\cdots~\sigma(f_n)$, write
%   $\sigma(f_1, \ldots, f_n)$.

% \item Search for a mapping $f: A \to B$ subject to two conditions:
%   \begin{itemize}
%   \item For each $(a_1,\ldots, a_k) \in A$, let $f(\vec a)$ be
%     $\vec{b}$ such that for every $a_i$, there exists a
%     $\vec{b'} \in \mathcal B_{a_i,i}$ such that
%     $\bracbb{b_1;\cdots;b_k} \subseteq \bracbb{b'_1;\cdots;b'}$. 
%   \item Let the map $f_i : A_i \to B$ select the corresponding
%     $\vec{b'}$, as above. Ensure
%     $\Phi_s\sigma(f_1,\ldots,f_k) \Rightarrow \Phi_t$.
%   \end{itemize}

% \item Now $f$ indiciates a set of solutions. To select one, whenever
%   $f(a) = \vec b$ has a nondeterministic action $b_j = \Angel C$,
%   replace $b_j$ with an arbitrary element of $C$.

% \end{itemize}