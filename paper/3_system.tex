\section{Syntax and Semantics}


\begin{figure}[ht]
  \[\begin{array}{l c l l}
      \multicolumn{4}{l}{\textit{Commands}}\\
      c & ::=& \\
        & \mid & x := e & \textsc{Assignment}\\
        & \mid & c;c & \textsc{Sequence} \\
        & \mid & c \angel c & \textsc{Angelic Choice}\\
        & \mid & \assert b & \textsc{Assertions} \\
        & \mid & \assume b & \textsc{Assumptions} \\
        & \mid & \apply t & \textsc{Table Application}\\
      \multicolumn{4}{l}{\textit{Expressions}} \\
      e & ::= & \\
        & \mid & v            & \textsc{BitVector} \\
        & \mid & x            & \textsc{Field} \\
        & \mid & e,e          & \textsc{Concatenation} \\
        & \mid & e \oplus e   & \textsc{Operation} \\
        & &  \multicolumn{2}{l}{\textit{where}\;\; \oplus \in \{+,-,\times, \div, \texttt{<<}, \texttt{>>} \}} \\
      \multicolumn{4}{l}{\textit{Booleans}}\\
      b & ::= & \\
        & \mid & \TRUE & \textsc{Truth} \\
        & \mid & \FALSE & \textsc{Falsity} \\
        & \mid & b \wedge b & \textsc{Conjunction} \\
        & \mid & b \vee b & \textsc{Disjunction} \\
        & \mid & \neg b & \textsc{Negation} \\ 
        & \mid & e = e & \textsc{Equality} \\
        & \mid & e \in X & \textsc{Membership} \\
      \multicolumn 3 l{\textit{Sets}} \\
      X &::=& \emptyset & \textsc{Empty} \\
        & \mid & \{e\} & \textsc{Singleton}\\
        & \mid & M & \textsc{Variable} \\
        & \mid & X \cup X & \textsc{Union}\\
     \multicolumn{2}{l}{\textit{Values}} & \textit{Fields}  & \textit{Variables}\\
     \multicolumn{2}{l}{v \in \mathbbm{2}^+} & x \in \mathsf{Var}_1 & M \in \mathsf{Var}_2
    \end{array}\]

  \caption{Syntax of GCL+Tables}
  \label{fig:syntaxgcl}
  
\end{figure}


\begin{figure}[ht]
  \[\begin{array}{l >{\triangleq}c l l >{\triangleq}c l}
      \multicolumn 3 l {\textit{Tables}}  & \multicolumn 3 l {\textit{Names}}\\
      \multicolumn 3 l {t::= (s,\vec e, \vec c, c_d)} & \multicolumn 3 l {s \in \Name}\\
      \multicolumn 6 c {\textit{Accessors}}\\
      \keys t && \vec x &  \default t && c_d \\
      \actions t && \vec c & \name t && s
    \end{array}\]

  \caption{Tables}
  \label{fig:tables}
\end{figure}

\begin{figure}[ht]
  \[\begin{array}{l >{\triangleq}c l}
      \wp_\tau(x:=e, \phi) && \phi[x \mapsto e]\\
      \wp_\tau(c;c', \phi) && \wp_\tau(c, \wp_\tau(c', \phi)) \\
      \wp_\tau(c\angel c', \phi) && \wp_\tau(c, \phi) \wedge \wp_\tau(c',\phi) \\
      \wp_\tau(\assert b, \phi) && b \wedge \phi \\
      \wp_\tau(\assume b, \phi) && b \Rightarrow \phi \\
      \wp_\tau(\apply t, \phi) && \wp_\tau(\parenbb{\apply t}_\tau, \phi)\\\\\hline\\
      
      \wp_\tau(c) && \wp_\tau(c,\displaystyle \bigwedge_{\substack{v \in \fvs(c) \\ \mathsf{fresh} v'}} v = v') \\
      \wp(c) && \wp_\bot(c), \quad c \text{ is table-free}
    \end{array}\]
  \caption{Weakest Preconditions}
  \label{fig:wp}
\end{figure}

\begin{figure}[ht]
  \[\begin{array}{l c l}
      \multicolumn{3}{c}{\textit{Configurations}\quad g \in \Config} \\
      \multicolumn 1 r g & ::= & \langle\rangle \\
        & \mid & (e,i)::g \quad i \in \mathbb N \\\\
      \multicolumn 3 l {\textit{Table Instantiations} \qquad \tau : \Name \rightharpoonup \mathsf{Config}}\\
      \parenbb{c}_\tau &\multicolumn 2 l {\in \mathsf{Cmd}} \\
      \parenbb{(x:= e)}_\tau &\triangleq& x := e \\
      \parenbb{(c;c')}_\tau &\triangleq& \parenbb{c\; \tau};\parenbb{c\; \tau} \\
      \parenbb{(c\angel c')}_\tau &\triangleq& \parenbb{c\; \tau} \angel \parenbb{c'\; \tau}\\
      \parenbb{(\assert b)}_\tau &\triangleq& \assert b \\
      \parenbb{(\assume b)}_\tau &\triangleq& \assume b \\
      \parenbb{\apply t}_\tau &\triangleq\\
      \multicolumn 3 l {\qquad\qquad \left( \displaystyle \Angel_{c_i \in \actions t}
      \assume{\left(\keys t \in M_i(g)\right)}; c_i\right)}\\
      \multicolumn 3 l {\qquad\qquad \displaystyle \angel \assume{\left(\bigwedge_{c_i \in \actions t} \keys t \not\in M_i(g)\right)}; c_d}
    \end{array}\]

  \caption{Configurations and Table Instantiations. A configuration is
    \emph{$t$-well-formed} if the $\vec e$s are unique and for every
    $i$, there is an action $c_i \in \actions t$.}
  \label{fig:configs}

  
  
\end{figure}


\todo[inline]{describe language~\ref{fig:syntaxGCL} and wp~\ref{fig:wp}}

As shown in Figure~\ref{fig:tables}, a table is a triple
$(s, \vec e, \vec c, c_d)$, where $s$ is the name of the table, the
variables $e_1,\ldots,e_n$ represent the table keys, the commands
$c_1,\ldots, c_m$ represent table actions, and $c_d$ represents the
default action, note that $c_d$ need not be equal to any of the other
actions. Also notice that we have omitted any consideration of action
data for the time being. This is because from a theoretical sense, we
can abstract away the action data by creating a new action for each
possible parameter. In practice this is infeasible (an action with a
single 48 bit argument would elaborate to $2^{48}$ actions), we'll
discuss our optimizations in a later section.

A table $t$ cannot be executed alone; it must have a configuration
(even if that configuration is empty). A configuration is a list of
pairs $(\vec e,i)$, which represents the match conditions for action
$i$. The empty configuration specifies that the default action should
be executed. A configuration $g$ is \emph{well-formed for a table $t$}
if for every element $(\vec e, i)$ of $g$, $|\vec e| = |\keys t|$, and
$i \leq |\actions t|$, and every $\vec e$ is a literal, i.e. no fields
and no holes.

\subsection{Translating Tables to GCL}

Now we can use the table configurations to convert a table into a core
GCL program, as depicted in Figure~\ref{fig:configs}. Essentially, we
nodeterministically choose between each of the actions $c_i$. However,
each $c_i$ is only executed if the packet matches one of the guarding
expressions. We collect these guarding expressions \emph{match-set}
$M_i$ of the $\vec e$s in config $g$ that trigger $c_i$. Precisely, we
define a function $M_i$ as follows:
\[M_i(g) \triangleq \{ e \mid (e,j) \in g, i = j\}.\]

Now, the we can translate the matches, we check to see whether the
current keys, indicated by $\keys t$, are in each set $M_i$, and when
we find a match, we execute $c_i$. If we find no match, we have a
final catch-all case, that executes $c_d$. We can lift configurations
to \emph{table instantiations} $\tau : \Name \to \Config$, which are
simply functions that map each table to a configuration. We say that a
table instantiation $\tau$ is $c$-complete if $\tau$ is defined on
$\name t$ for every table $t$ mentioned in the program $c$. Then, for
a program $c$ and a $c$-complete $\tau$, we write $\parenbb{c\; \tau}$
for the command with all table applications compiled away.

We want to show that our encoding is correct, so we introduce a semantics for
commands $c$ and for $c,\tau$ pairs, and show that
$\bracbb{\parenbb{c\; \tau}} = \bracbb{c\; \tau}$. The semantics for full
programs are given in Figure~\ref{fig:semantics}, but the work is done on
single-tables and single configurations. Figure~\ref{fig:tablesemantics} defines
$\bracbb{t\; g} : \Pkt \to \Pkt$ for a table $t$ and configuration $g$.

\begin{figure}[ht]
  \[\begin{array}{lcl}
      \bracbb{t}_{\langle\rangle}\; \pkt
      &\triangleq& \bracbb{\default t}\; \pkt \\
      \bracbb{ t }_{(\vec e, i)::g}\; \pkt
      &\triangleq& \begin{cases}
        \bracbb{c_i}\; \pkt & \displaystyle \bigwedge_{e_j} \bracbb{k_j = e_j}\; \pkt \\
        \bracbb{t}_{g}\; \pkt & \mathit{otherwise}
      \end{cases}\\
      && \mathit{where}\; t = (s, \vec k, \vec c, c_d)
    \end{array}\]
  \caption{Semantics for a Single Table}
  \label{fig:tablesemantics}
\end{figure}


\begin{figure}[ht]
  \[\begin{array}{lcl}
      \multicolumn 3 l {\bracbb{c}_\tau : \Pkt \rightharpoonup 2^\Pkt_\bot} \\
      \bracbb{(x:=e)}_\tau\; \pkt & \triangleq & (1,\pkt[x \mapsto e]) \\
      \bracbb{(c;c')}_\tau\; \pkt & \triangleq & \bracbb{c'\; \tau}^\dag(\bracbb{c\; \tau}\; pkt) \\
      \bracbb{(c\angel c')}_\tau\; pkt &\triangleq& \bracbb{c\; \tau}\; \pkt \cup \bracbb{c'\; \tau}\; \pkt \\
      \bracbb{(\assert b)}_\tau\; \pkt &\triangleq& \begin{cases}
        \{pkt\}   & \bracbb{b}\; \pkt = \TRUE \\
        \bot & \mathit{otherwise}
      \end{cases} \\
      \bracbb{(\assume b)}_\tau\; \pkt &\triangleq& \begin{cases}
        \{pkt\} & \bracbb{b}\; pkt = \TRUE \\
        \emptyset    & \mathit{otherwise}
      \end{cases} \\
      \bracbb{(\apply t)}_\tau\; \pkt &\triangleq& \bracbb{\apply t\; \tau(t)} \\\\\hline\\
      \bracbb c \; \pkt & \triangleq& \bracbb{c}_\bot\; \pkt

    \end{array}\]
  
  \caption{Semantics}
  \label{fig:semantics}

\end{figure}

Now we can show that our table encoding is sensible:

\begin{lemma}
  \label{lem:table-encoding}
  For a table $t$ and a well-formed configuration $g$,
  \[\forall \pkt. \bracbb{t}_{g}\; \pkt = \bracbb{\parenbb{t}_g}\;
  \pkt.\]

\end{lemma}

\begin{proof}
  Let table $t$, and packet $\pkt$ be given. Proceed by induction on
  $g$.
  \begin{enumerate}[align=left]
  \item[($g = \langle \rangle$)] Equivalently,
    $\bracbb{c_d}\;\pkt = \bracbb{\assume\TRUE; c_d}\; \pkt$, for
    $c_d = \default t$. This is true by definition of $\bracbb{}$.

  \item[($g = (\vec e,i)::g')$] 
    
    If $\bracbb{\keys t = \vec e}\; \pkt = 1$, then,
    $\bracbb{t}_{(\vec e, i)::g'}\;\pkt = \bracbb{c_i}\; \pkt$, by
    Figure~\ref{fig:tablesemantics}.

    Now, by definition of $M_i$,$\bracbb{\keys t \in M_i}\; \pkt =
    1$. The well-formedness of $(\vec e, i)::g'$ means that there's no
    conflicting $(\vec{e'}, j) \in g'$ s.t.
    $\exists \pkt. \bracbb{\keys t = \vec{e}}\; \pkt = \bracbb{\keys t
      = \vec{e'}}\; \pkt$.  So, $\bracbb{t}_{(\vec e,i)::g'}\; \pkt$
    equals $\bracbb{\assume{\keys t \in M_i}; c_i}\;\pkt$ which in
    turn equals $\bracbb{c_i}\; \pkt$, which finishes this case.
    
    Conversely, if $\bracbb{\keys t = \vec e}\; \pkt = 0$, then
    $\bracbb{\apply t}_{(\vec e, i)::g'}\;\pkt =
    \bracbb{t}_{g'}\;\pkt$.  Now, by definition of $M_i$,
    $\bracbb{\keys t \in M_i}\; \pkt = 0$, so
    $\bracbb{\keys t \in M_i}\; \pkt = 0$, which means that we can
    remove $\vec e$ from $M_i$. In fact, this is the only difference
    between $\parenbb{t}_{g}$ and $\parenbb{t}_{g'}$, so we can conclude
    that
    $\bracbb{\parenbb{t}_{(e,i)::g}}\;\pkt =
    \bracbb{\parenbb{t}_{g'}}\;\pkt$. The result follows by the
    inductive hypothesis.
  \end{enumerate}
  
\end{proof}

\begin{proposition}
  For a program $c$ and a well-formed, $c$-complete table
  instantiation function $\tau$,
  $\forall \pkt. \bracbb{c}_{\tau}\;\pkt =
  \bracbb{\parenbb{c}_{\tau}}\; \pkt$.
\end{proposition}

\begin{proof}

  Proceed by induction on the structure of $c$.
  \begin{enumerate}[align=left]
  \item[($x:=e$)] Immediate since $\parenbb{x:=e}_{\tau} \triangleq x := e$.
  \item[($\assert b$)] Immediate since
    $\parenbb{\assert b}_{\tau} \triangleq \assert b$.
  \item[($\assume b$)] Immediate since $\parenbb{\assume b}_{\tau} \triangleq \assume b$.
  \item[($c;c'$)] By the definition of the translation function,
    $\parenbb{c;c'}_{\tau} = \parenbb{c}_{\tau};\parenbb{c'}_{\tau}$,
    and by the definition of the denotation function, we need to show
    that
    $\forall
    \pkt. \bracbb{c}_\tau^\dag\left(\;\bracbb{c'}_\tau\;\pkt\right) =
    \bracbb{\parenbb{c}_\tau}^\dag\left(\bracbb{\parenbb{c'}_\tau}\;\pkt\right)$,
  which follows by the inductive hypotheses.
  \item[($c \angel c'$)] By definitions, we must show
    $\forall \pkt. \bracbb{c}_\tau\; \pkt \cup \bracbb{c}_\tau\;
    \pkt = \forall \pkt. \bracbb{\parenbb{c}_\tau}\; \pkt \cup
    \bracbb{\parenbb{c}_\tau}$, which follows by the inductive
    hypotheses.
  \item[$(\apply t)$] By definitions, we must show
    $\forall \pkt. \bracbb{t}_{\tau(\name t)} =
    \bracbb{\parenbb{t}_{\tau(\name t)}}$. Note that $\tau(\name t)$
    is defined since $\tau$ is complete. The result follows by
    Lemma~\ref{lem:table-encoding}.
  \end{enumerate}
\end{proof}


\section{Verification and Synthesis}


\begin{figure*}
  \begin{tabular}{l l c c r >{$ \Leftrightarrow$}c l}
    \toprule
    && Problem
    & Assumption
    & \multicolumn{3}{c}{Validity Condition} \\ \midrule
    \multirow{3}{*}{\rotatebox[origin=c]{90}{\it Basic}} 
    && $\textsc{Verif}(\tau_l, \tau_r)$
    & n/a
    & $\wp_{\tau_l}(c_l)$ && $\wp_{\tau_r}(c_r)$ \\
    && $\textsc{InstSynth}(\tau_l) = \tau_r$
    & n/a
    & $\wp_{\tau_l}(c_l)$ && $\wp_{\tau_r}(c_r)$ \\
    && $\textsc{MapSynth}() = F$
    & n/a
    & $\forall \tau_l. \wp_{\tau_l}(c_l)$ && $\wp_{f(\tau_l)}(c_r)$ \\ \midrule
    \multirow{4}{*}{\rotatebox[origin=r]{90}{\it Edit-based}}
    && $\textsc{EditSynth}() = f$
    & $\wp_{\tau_l}(c_l) \Leftrightarrow \wp_{\tau_r}(c_r)$
    & $\forall \rho. \wp_{(\tau_l \otimes \rho)}(c_l)$ && $\wp_{\left(\tau_r\otimes \bigotimes f(\rho)\right)}(c_r)$ \\ \cmidrule(r){2-7}
    % & \textsc{EditSynth}$(\oplus, s)$
    % & n/a
    % & $\wp(c_l\; \tau_l) \Leftrightarrow \wp(c_r\; \tau_r)$
    % & $f : \mathsf{Edit}_s \to 2^{\mathsf{Edit}}$
    % & $\forall \rho_{s}. \wp(s^\oplus\parenbb{c_l}_{(\tau_l \oplus \rho_s)})$ \\
    % &&&&\qquad$\Leftrightarrow \wp\left(\hole\parenbb{c_r}_{\left(\tau_r\otimes \bigotimes f(\rho_s)\right)}\right)$ \\
    & \multirow{3}{*}{\rotatebox[origin=r]{90}{\it Bound}}
    & $\textsc{EditCheck}[n]()$
    & $\wp_{\tau_l}(c_l) \Leftrightarrow \wp_{\tau_r}(c_r)$
    & $\forall \rho_s. \exists \rho_1, \ldots, \rho_n. \wp(\parenbb{c_l}_{\tau_l}^\rho)$
    &&$\wp(\parenbb{c_r}_{\tau_r}^{\rho_1,\ldots,\rho_n})$ \\
    && $\textsc{EditSynth}[n]() = f_1,\ldots, f_n$
    & $\wp_{\tau_l}(c_l) \Leftrightarrow \wp_{\tau_r}(c_r)$
    & $\forall \rho. \wp(\parenbb{c_l}_{\tau_l}^\rho))$ && $\wp(\parenbb{c_r}_{\tau_r}^{f_1(\rho),\ldots,f_n(\rho)})$ \\
    && $\textsc{EditVerif}[n](f_1,...,f_n)$
    & $\wp_{\tau_l}(c_l) \Leftrightarrow \wp_{\tau_r}(c_r)$
    & $\forall \rho. \wp(\parenbb{c_l}_{\tau_l}^\rho))$ && $\wp(\parenbb{c_r}_{\tau_r}^{f_1(\rho),\ldots,f_n(\rho)})$\\ \addlinespace
    \bottomrule
  \end{tabular}
  \caption{Cheat Sheet for the Verification and Synthesis problems.\textit{ All
      problems take $c_r$ and $c_l$ as given. Additional givens are in
      parentheses.  Problem parameters are given in square brackets. Note,
      $F : \mathsf{Inst} \to \mathsf{Inst}$, $f : \Edit \to 2^\Edit$ and
      $f_i : \Edit \to \Edit$ }}
  \label{fig:problems}
\end{figure*}

We can use this calculus to construct some verification and synthesis
problems. Broadly we want to take a logical program $c_l$ and a concrete program
$c_r$, relate their respective table instantiations $\tau_l$, and $\tau_r$,
where $\tau_i$ is $c_i$-complete.  We generate our verification conditions using
Dijkstra's weakest precondition semantics, included for completeness in
Figure~\ref{fig:wp}.

\paragraph{Verification} The simplest problem is the verification problem
\textsc{Verif} where we are given the table instantiations $\tau_l$ and
$\tau_r$, and we want to verify that $c_l\; \tau_l$ is equivalent to
$c_r\; \tau_r$. Since everything is concrete, we can encode this as a simple
\textsc{sat} problem. If the following problem returns \texttt{unsat}, we
conclude $c_l\; \tau_l$ and $c_r\; \tau_l$ are equivalent.
\[\begin{array}{lcl}
    \text{Given }( c_l\; \tau_l), (c_r\; \tau_r) \\
    \exists \fvs(c_l), \fvs(c_r). \\
    \qquad \neg(wp(c_l\; \tau_l) \iff wp(c_r\; \tau_r))
  \end{array}
\]

\paragraph{Synthesizing a Concrete Instance} One step up, we have the
\textsc{InstSynth} problem, where only the logical table instantiation is given,
and we must produce a $\tau_r$ satisfying the \textsc{Verif} condition. If we
get \texttt{sat} and a model for $\tau_r$ from Z3 we conclude success.
\[\begin{array}{lcl}
    \text{Given } c_l\; \tau_l,c_r
    \exists \tau_r.\\
    \forall \fvs(c_l), \fvs(c_r). \\
    \qquad wp(c_l\; \tau_l) \iff wp(c_r\; \tau_r)
  \end{array}
\]

In a real network, this means that every time the
controller changes the logical forwarding state, we must resynthesize the
concrete forwarding state. However, network engineers care very deeply about the
predictability of their networks, and inserting a heuristic shim in the middle
of the network would make it very hard to exert the kind of control that network
engineers rely on.

\paragraph{Synthesizing an Instance Mapping} To ameliorate this problem, we consider the \textsc{MapSynth} problem, which
synthesizes a function $f$ from an arbitary logical instantiations $\tau_l$ to a
concrete table instantiation that will implement the same functionality as
$\tau_l$. The offline synthesis succeeds the following formula is \texttt{sat}
and the witness for $f$ is the solution.
\[\begin{array}{l}
    \text{Given } c_l,c_r\\
    \exists f. \forall \tau_l. \forall \fvs(c_l), \fvs(c_r). \\
    \qquad wp(c_l\; \tau_l) \iff wp(c_r\; f(\tau_l))
  \end{array}\]
However this function $f$ is really quite large, and for even trivial
examples causes Z3 to return \texttt{unknown}. So, we need to find a way of
partitioning the \textsc{OfflineSynth} problem into more tractable
components.

\paragraph{Edit-Based Synthesis} Instead of trying to synthesize an arbitrary
function from table instantiations to table instantiations, we reframe the
problem to examining only the table edits, and call it \textsc{EditSynth}. The
idea is: given two equivalent programs, for every edit to a logical table, can
we synthesize an equivalent set of edits to the concrete tables. This means we
synthesize (offline!) two different functions for each table, one for additions
and one for deletions. This works so long as we have a notion of transactions.

\todo[inline]{The following functions and objects need types!}


\begin{figure}[pt]
  \[\rho \in \Edit = \{ +, -\} \times \Name \times \Expr^n \times \mathbb N \]
  \[\begin{array}{lcl}
      \tau \otimes (+,s,\vec e, i) & \triangleq & \tau[s \mapsto (e,i)::\tau(s)] \\
      \tau \otimes (-,s,\vec e, i) & \triangleq & \tau[s \mapsto \tau(s) \setminus (e,i)] \\
      \tau + (+, s, \vec, e, i) & \triangleq & \tau \otimes (+,s, \vec e,i) \\
      \tau - (-, s, \vec, e, i) & \triangleq & \tau \otimes (-, s, \vec e, i) 
    \end{array}\]

  \[\begin{array}{lcl}
      \rho_s & \triangleq & (\oplus, s', \vec e, i), \text{where } s = s'\\
      \Edit_s &\triangleq & \{\rho_s \mid \rho_s\in \Edit\} \\
    \end{array}\]
  \caption{Edits}
  \label{fig:edits}
\end{figure}

Formally, an edit $\rho \in \mathsf{Edit}$ is a tuple
$(\oplus,s,\vec e,i)$, where $\oplus \in \{+,-\}$, $s$ is the name of
the table being edited, and $(\vec e, i)$ is the row to add. Then,
given a table instantiation function $\tau$, we write
$\tau \otimes \rho$ to update $\tau$ with $\rho$. Precisely,
$\tau \otimes (+,t,\vec e, i) = \tau[t \mapsto (e,i)::\tau(t)]$, and
$\tau \otimes (-, t, \vec e, i) = \tau[t \mapsto \tau(t) \setminus
(e,i)]$ where $l \setminus (e,i)$ removes all occurences $(e,i)$ from
the list $l$. As syntactic sugar, we'll write $\tau + \rho$ to mean
$\tau \otimes \rho$ when $\rho = (+, s, \vec e, i)$, and $\tau - \rho$
to mean $\tau \otimes \rho$ when $\rho = (-, s, \vec e,
i)$. Additionally, we adopt the convention that $\rho_s$ indicates an
edit to all tables named $s$, i.e. that
$\rho_s = (\oplus, s, \vec e, i)$. Similarly, $\mathsf{Edit}_s$ is the
set of all such edits. Edits are summarized in Figure~\ref{fig:edits}.



A solution for \textsc{EditSynth} is a witness $f$ for every table $t$ such that
the following formula is satisfied:
\[\begin{array}{l}
    \text{Given } c_l,c_r, \exists \rho. \\
    \forall \tau_l,\tau_r,\rho. \forall \fvs(c_l), \fvs(c_r). \\
    \qquad \wp(c_l\; \tau_l) \iff wp(c_r\; \tau_l) \\
    \qquad \Rightarrow \wp(c_l\; (\tau_l \otimes \rho)) \iff \wp(c_r\; \tau_r \otimes (f(\rho)))
  \end{array}\]

For now we have only figured out how to address a simpler version of the
problem:

A solution for \textsc{EditSynth'} is a series of actions $\vec{\rho'}$ for every table $t$ such that
the following formula is valid:
\[\begin{array}{l}
    \text{Given } c_l,c_r, \\
    \forall \rho, \tau_r, \tau_l.\, \exists n.\, \exists \hole\rho_1,\ldots,\hole\rho_n. \\ 
    \quad \forall \fvs(c_l), \fvs(c_r). \\
    \qquad \wp(c_l\; \tau_l) \iff wp(c_r\; \tau_l) \\
    \qquad \Rightarrow \wp(c_l\; (\tau_l \otimes \rho)) \iff \wp(c_r\; \tau_r
    \otimes \hole\rho_1 \otimes \cdots \otimes \hole\rho_n )
  \end{array}\]

In practice, we will can even produce problems \textsc{EditSynth}$(\oplus,s)$
where the universal $\rho$ is restricted so that its first two elements are
$\oplus$ and $s$.



\subsection{Synthesis via Bounded Model Checking}

\todo[inline]{explain why this problem is too big}

In order to shrink the complexity of the problem, we leverage the finiteness of
updates. A single update to a single table can only affect finitely many
tables. We suspect that there is a concrete upper bound on the number of
concrete rules will need to be inserted or deleted for any single logical rule
update. \todo[inline]{Think about this more deeply}

We use a technique similar to \emph{bounded model checking} to exploit the
finite effect of each rule. In bounded model checking are asking the question
for a given model size $n$. That is, \emph{for every logical edit $\rho$, does
  there exists a sequence of exactly $n$ concrete edits $\rho_1, \ldots, \rho_n$
  that produce equivalent changes}?

\begin{example}
  Bounded Model Checking is tricky to do correctly, because a single
  logical edit can require many concrete edits. Consider a logical program
  \[\begin{array}{l}
      \apply{l, \langle  \texttt{dst} \rangle, \langle \underline{\texttt{op} := 1}, \texttt{op} := 0 \rangle}
    \end{array}
  \]
  and a concrete program
  \[\apply{r, \langle \texttt{src}, \texttt{dst} \rangle, \langle \underline{\texttt{op} := 1}, \texttt{op} := 0 \rangle}.\]
  
  A function $f$ that maps logical edits into concrete edits, requires
  $|\texttt{src}|$ concrete edits for every logical edit.
\end{example}

To lift this to a synthesis problem, called $\textsc{EditSynth}[n]$ for a given
$n$, we will instead synthesize a sequence of $n$ functions
$f_i : \Edit \to \Edit$, each producing a single $\rho$, such that applying the
sequence of edits $f_1(\rho), \ldots, f_n(\rho)$ to the concrete network has the
same effect as applying $\rho$ to the logical network. This problem is described
in Figure~\ref{fig:problems}.

Our compilation of GCL programs with tables to GCL programs without tables so
far only works with concrete encodings. Figure~\ref{fig:symbolic-encoding} presents a
symbolic encoding that allows for symbolic (or concrete) edits to be inserted.

\begin{figure}[ht]
  \[\begin{array}{r >{\triangleq}c l}
      \parenbb{x:=e}_\tau^{\vec\rho}
      && x:=e\\
      \parenbb{c;c'}_\tau^{\vec\rho}
      && \parenbb{c}_\tau^{\vec\rho};\parenbb{c'}_\tau^{\vec\rho} \\
      \parenbb{c \angel c'}_\tau^{\vec\rho}
      && \parenbb{c}_\tau^{\vec\rho} \angel \parenbb{c'}_\tau^{\vec\rho} \\
      \parenbb{\assert b}_\tau^{\vec\rho}
      && \assert b\\
      \parenbb{\assume b}_\tau^{\vec\rho}
      && \assume b\\
      \parenbb{\apply {s,\vec k, \vec c, c_d}}_\tau^{\vec\rho}
      && \displaystyle \Angel_{c_i}\mathsf{matchDel}(\tau, \vec\rho, s, c_i) \\
      \multicolumn 2 l {} & \angel \mathsf{newMatches}(\vec\rho, \vec k, s, \vec c) \\
      \multicolumn 2 l {} & \angel \mathsf{newDefault}(\tau, \vec\rho, \vec k,s, \vec c, c_d)\end{array}\]
  \[\begin{array}{r c l}
      \hline\\
      \mathsf{matchDel}(\tau,\vec\rho,s,c_i)
      &\triangleq
      &\assume{\vec k \in M_i(\tau(s))} \\
      &;&\assume{\bigwedge_{(-,s,\vec e, i) \in \vec \rho} \vec k \neq \vec e}\\
      &;&c_i \\
      \mathsf{newMatches}(\vec\rho, \vec k, s, \vec c)
      &\triangleq
      &\displaystyle \Angel_{(+,s,\vec e, i) \in \rho} \assume {\vec k = \vec e}; c_i \\
      \mathsf{newDefault}(\tau, \vec\rho,\vec k, s, \vec c, c_d) &\triangleq& \assume \bigwedge_{c_i}k\not\in M_i(\tau_s) \\
      && \qquad\;\;\vee \bigvee_{(-,s,\vec e, i) \in \rho} \vec k = \vec e\\
      &;& c_d
    \end{array}\]
  \caption{Symbolic Encoding of Tables, and helper functions}
  \label{fig:symbolic-encoding}

\end{figure}

In order to properly synthesize these $f_i$s, we leverage both Counter Example
Guided Inductive Synthesis (CEGIS)~\cite{CEGIS}, and Sketch~\cite{Sketch}. We
describe the algorithm in $N$ steps.

\paragraph{Step 0: Initialization.} The inputs are we are given two unconfigured
network programs, a \textbf{l}ogical program $c_l$ and a conc\textbf{r}ete
program $c_r$. When a network begins running, every table starts off with the
empty configuration: $\langle\rangle$. So, we provide $c_l$ with such an
instantiation: $\lambda s. \langle \rangle$. Since we have this concrete
instantiation, we can solve $\textsc{InstSynth}(\lambda s. \langle\rangle)$ to
produce a configuration $\tau_l$ such that
$\wp_{\langle\rangle}(c_r) \Leftrightarrow \wp_{\tau_l}(c_l)$.

\paragraph{Step 1: Search for Model Size.} Now that the assumption for
$\textsc{EditCheck}[n]$, for all $n$ is satisfied, we can attempt to solve for
both $n$, by searching for the minimum $n$ via a grid search.

\paragraph{Step 2: Synthesize $f_i$s.} Now, we can solve $\textsc{EditSynth}[n]$
for the $n$ we computed in the previous step. To do this, we leverage
Synthesis-by-Sketching and CEGIS. The sketch that we use to model each $f_i$ is
the following:
\[f_i(\rho) \triangleq \texttt{repeat}(*)\left(\texttt{if }(?\rho_i = \rho)\;\{\texttt{return }?\rho'_i\}\right)\]

which examines the value of $\rho$ some number () of times by comparing it with
the hole $?\rho_i$ and producing a corresponding hole $?\rho'$. We generate
candidate solutions $f_1,\ldots, f_n$ by solving $\textsc{EditSynth}[n](\rho)$
for a randomly generated $\rho$. Now we can generate counter-examples $\rho_c$
by having Z3 attempt to solve $\textsc{EditVerif}[n](f_1,\ldots,f_n)$; we
terminate if Z3 proves that there is no counter example, otherwise, we loop back
to $\textsc{EditSynth}[n](\rho_c)$. \todo[inline]{widening? Narrowing?}

\paragraph{Step 3: Produce $f$} Once we've synthesized the collection of
$f_1, \ldots, f_n$, we can produce $f = \textsc{EditSynth}()$ by setting
\[f(\rho) = \{f_1(\rho), \ldots, f_n(\rho)\}\]


\todo[inline]{well that didn't work, Z3 complained at the nested quantifiers}


\subsection{Action-Directed Synthesis}

Observe that in the previous formulations, all of the higher-orderness
comes from the unknown match conditions. What if, \emph{a la} \texttt{p4v} we
just elminiate the matches, and model tables as a demonic choice
between all of the actions. We formalize this notion in
Figure~\ref{fig:nondeterministic}, using $|c|$ to represent this
encoding.

\begin{figure}[ht]
  \[\begin{array}{l >{\triangleq}c l}
      |x := e| && x := e  \\
      |c;c'| && |c|;|c'| \\
      |c \angel c'| && |c|\angel |c'| \\
      |\assert b | && \assert b \\
      |\assume b | && \assume b \\
      |\apply {t, \vec k, \vec{c}, c_d}| && h_1^t := 0; \cdots ; h_n^t := 0; h_d^t := 0; \\
      \multicolumn 2 l {} & \Bigg(\bigg(\displaystyle\Angel_{c_i \in \vec c} c_i; h_i^t := 1\bigg) \angel c_d; h^t_d := 1 \Bigg); \\
      \multicolumn 2 l {} & \assert {h^t_d \veebar (\exists!c_i. (h_j^t))} 
    \end{array} \]
  \caption{Nondeterministic Encoding of Tables}
  \label{fig:nondeterministic}
\end{figure}

Now we can define a problem \textsc{NonDetVerif} which is a very
coarse-grained check -- it rules out program pairs that have
incompatible sets of actions. Given two programs $c_l$ and $c_r$, we
can simply check the validity of the following:

\[\forall\pkt, \pkt'.\; \wp(|c_l|, \pkt = \pkt') \Leftrightarrow \wp(|c_l|, \pkt = \pkt') \]

\begin{example}
  Let
  $c_l = \apply{\texttt{ip}, (\texttt{pt}), \langle \texttt{ip.src} :=
    4 \rangle , \assert \TRUE }$, and let
  $c_r = \apply {\texttt{tcp}, (\texttt{pt}), \langle \texttt{tcp.src}
    := 4 \rangle, \assert \TRUE}$. Intuitively, This pair will not
  pass the \textsc{NonDetVerif} condition, because the \texttt{ip}
  table modifies the \texttt{ip.src} variable and the \texttt{tcp}
  table modifies the \texttt{tcp.src} variable. We compute
  $|c_l| = \texttt{ip.src}:=4 \angel \assert \TRUE$ and
  $|c_r| = \texttt{tcp.src} := 4 \angel \assert \TRUE$. So,
  $\wp(|c_l|) \Leftrightarrow \wp(|c_r|)$ is equivalent to
  $(\texttt{ip.src}' = 4 \wedge \texttt{tcp.src} = \texttt{tcp.src}')
  \Leftrightarrow (\texttt{ip.src}' = \texttt{ip.src}' \wedge
  \texttt{tcp.src}' = 4)$, which is clearly false in general.
\end{example}


The intuition here, is that \textsc{NonDetVerif} is a necessary, but
not sufficient condition for the above solutions,
i.e. $\textsc{MapSynth} \Rightarrow \textsc{NonDetVerif}$.

There is an easy generalization of this check to a synthesis problem,
we want to check which actions are feasible implementations of a given
action in a given table. We call this the \emph{feasible domain} of an
action-table pair. We again, need to come up with a different, but
related encoding of tables for a given action-table pair $(c_i,
s)$. This is defined in Figure~\ref{fig:hitenc}. The problem of
computing the a path that can implement an action is
\[\textsc{PathSynth}(c_i, s) = \left\langle h_j^t \mid c_j \in \actions t \cup \{\default t\},
    t \in \Tables {c_r}\right\rangle,\] which produces a collection of
bits $h_j^t$, which are set to true if action $c_j \in \actions t$ can
be used to implement action $c_i \in \actions s$. The set of solutions
to \textsc{PathSynth} is the feasible domain. Notice again that
\textsc{PathSynth} is a necessary, but insufficient condition -- if
there is no path, then \textsc{MapSynth} cannot succeed.

\begin{figure}[ht]
  \[\begin{array}{l>{\triangleq}cl}
      \mathcal H | x:= e | && x := e \\
      \mathcal H | c; c'| && \mathcal H |c|;\mathcal H |c'| \\
      \mathcal H | c \angel c'| && \mathcal H | c | ; \mathcal H | c' | \\
      \mathcal H | \assert b | && \assert b \\
      \mathcal H | \assume b | && \assume b \\
      \mathcal H | \apply{t, \vec k, \vec c, c_d} | && \assert {h_d^t \veebar \exists! c_i. h_i^t }; \\
      \multicolumn 2 l {} & \left(\displaystyle\Angel_{c_i}\assume {h_i^t};c_i \right) \angel \assume {h^t_d} ; c_d      
    \end{array}\]
  \caption{Instrumentation to for Feasible Domain Synthesis. The
    ($\exists!$) can be desugared in the obvious way since $\vec c$ is
    finite. This assumption ensures that the table is deterministic,
    i.e. the $h_i^t$s pick out a path.}
  \label{fig:hitenc}
\end{figure}

Then, we can define solutions to $\textsc{DomSynth}(c_i,s)$ by a
satisfying model to the following formula:
\[\begin{array}{l}\exists (h_i^t)_{\left(\substack{t \in \Tables{c_r} \\ c_i \in \actions t }\right)}. \;\forall \pkt. \; \forall \pkt'. \\
    \qquad \wp(\mathcal H |c_l|, \pkt = \pkt') \Leftrightarrow \wp(\mathcal H |c_r|, \pkt = \pkt') \end{array}\]


Now that we have a collection of the possible ways to encode the
actions, we need to make sure that our tests can be encoded
effectively. Morally, we want to know that a rule addition will only
impact the same set of equivalence classes that it would impact in the
logical program.
%
%
\[ \bracbb{c_l }_{\tau_l \otimes \rho}\; \pkt \neq \bracbb{c_l}_{\tau_l} \; \pkt \Leftrightarrow
  \bracbb{c_r}_{\tau_l \otimes \bigotimes f(\rho)} \neq \bracbb{c_r}_{\tau_l}\; \pkt \]


\begin{proposition}[Edit Completeness]
  Our axioms are sufficient to construct an $f : Edit \to \Edit^*$,
  given (logical and concrete) deterministic, total programs $c_l$ and
  $c_r$, such that for every pair of complete instantiations $\tau_l$
  and $\tau_r$, such that
  $\bracbb{c_l}_{\tau_l} = \bracbb{c_r}_{\tau_l}$, then, for every
  $c_l$-well-formed $\rho \in \Edit$ such that
  $\tau_l \neq \tau_l \otimes \rho$, then
  $\bracbb{c_l}_{\tau_l \otimes \rho} = \bracbb{c_r}_{\tau_l \otimes
    f(\rho)}$
\end{proposition}


\begin{proof}
  Let $\rho = (+, s, \vec e, i)$. Consider an input packet $\pkt$, and
  run $\bracbb{c_l}_{\tau_l}\; \pkt$. Since $c_l$ is deterministic and
  total, there is a table trace, $\sigma_l \in \Edit^*$ corresponding
  to the rows that $\pkt$ hits in $c_l$ instantiated with
  $\tau_l$. There is another table trace $\sigma_l^\rho$ corresponding
  to the tables hit by $\pkt$ when running
  $\bracbb{c_l}_{\tau_l \otimes \rho}\; \pkt$.

  Now there are two cases, either $\sigma_l = \sigma_l^\rho$, or not.



  Consider the case where
  $\bracbb{c_l}_{\tau_l}\; \pkt_0 = \bracbb{c_l}_{\tau_l \otimes \rho}
  \; \pkt_0$. Then,
  $\pkt = \pkt_0 \wedge \wp(\parenbb{c_l}_{\tau_l}, \pkt = \pkt')
  \Leftrightarrow \pkt = \pkt_0 \wedge \wp(\parenbb{c_l}_{\tau_l
    \otimes \rho}, \pkt = \pkt')$. Further, since
  $\tau_l \otimes \rho \neq \tau_l$, we know that $\pkt$ misses
  $\rho$\todo[inline]{formalize}


  We need to show that
  $\pkt = \pkt_0 \wedge \wp(\parenbb{c_r}_{\tau_r}, \pkt = \pkt')
  \Leftrightarrow \pkt = \pkt_0 \wedge \wp (\parenbb{c_r}_{\tau_r
    \otimes f(\rho)}, \pkt = pkt')$.


  There are a few situations we need to consider in this proof
  \begin{itemize}
  \item $\pkt_0$ hits $\rho$ and $\pkt_0$ hits a sub-trace of
    $f(\rho)$. This can be proven by restricting the programs to the
    respective actions.
    
  \item $\pkt_0$ hits $\rho$ and $\pkt_0$ misses all of
    $f(\rho)$. Contradictory if we assume $\rho$ is effectful.

  \item $\pkt_0$ misses $\rho$ and $\pkt_0$ hits a sub-trace of $f(\rho)$.
  \item $\pkt_0$ misses $\rho$ and $\pkt_0$ misses of $f(\rho)$. This
    can be proven by restricting the programs to miss the traces.
  \end{itemize}
  
\end{proof}

\subsection{Lets start small -- Single-table Switches}

Assume we can convert our programs into a single table with infinite
rows that allows choice in the actions (we can do it for a disjunction
thereof or if we add wild-cards, but for now just imagine a single
table). The problem becomes much simpler. We want to map one table
into another. How do we do this?

We need to map actions -- which we can do using \textsc{DomSynth} and
then make sure we can always discriminate them via the keys. Note that
in this context, \textsc{DomSynth} is picking out a single concrete
action for each logical action.

So now all we need to do is constrain \textsc{DomSynth} so that it is
possible for the keys to discriminate between the actions.
%
% Given a
% mapping on actions $f_a$, we need $f_a(c_i)$ to be determined by a
% superset of the same fields as $c_i$. We denote this formally: given
% $\vec k \longrightarrow c_i$ we need
% $\vec {k'} \longrightarrow f_a(c_i)$ , where
% $\vec k \subseteq \vec {k'}$. Further, if we have logical actions
% $ \vec {k_1} \longrightarrow c_i, \vec {k_2} \longrightarrow c_j$,
% with $i \neq j$, and $\vec {k_1} \neq \vec{k_2}$ such that
% $\vec {k_r} \longrightarrow f_a(c_i), f_a(c_j)$, then we need a
% ``separable'' function of type
% $f_k : \vec {k_1} + \vec{k_2} \to \vec{k_r}$. Specifically, we need to
% know that
% \[
%   \not \exists \vec{v_1}, \vec{v_2}. \; f_k^1(\vec{v_1}) = f_k^2(\vec{v_2})
% \]
% in addition to the functional constraint that
% \[
%   \forall \pkt.\; \pkt = \vec{v_i} \Leftrightarrow \pkt = f_k^i(\vec{v_i}), \quad i = 1,2
% \]
%
Specificaly, given constants $h_{i,j}$ which tell us that logical
action $c_i$ is implemented as concrete action $c_j$, we want to
synthesize functions $f : \Expr^n \times \mathbb N \to \Expr^m \times \mathbb N $ and activation
bits $h_{i,j}$, which map logical keys to concrete keys subject to the
following conditions:
\begin{enumerate}[align=left]
% \item[$(\textsc{Discernable})$]
%   $\forall \vec k, i. ~ \pkt \sim \vec {k} \vee i = a \Leftrightarrow
%   (\exists! j. f_{i,j}(\vec {k}) \sim \pkt \vee j = b)$
\item[$(\textsc{Implementable})$] \((\pkt \sim \vec{k} \wedge \wp(c_i, \pkt = \pkt') \Leftrightarrow \pkt \sim f_1(\vec k, i) \wedge \wp(d_{f_2(\vec k, i)}, \pkt = \pkt'))\)
\end{enumerate}


We say the function $f$ is \emph{consistent} if it satisfies these
properties. Then we construct a solution to the problem
$\textsc{EditSynth}(\apply{L, \vec k, \vec c, a}, \apply{R, \vec k,
  \vec d, b})$ as follows
\[ f^c(+,L,\vec v, i) = \{(+,R,\vec u, j) \mid (\vec u,j) = f(\vec v,i) \} \]

Note that \textsc{Disjoint} and \textsc{ActEq} constraints on
$h_{i,j}$ means that $|f^c(\rho)|$ is always 1, so w.l.o.g., we can
consider $f^c$ to have the following type $f^c : \Edit \to \Edit$.

\begin{theorem}
  $f^c$ is a solution to
  $\textsc{EditSynth}()$ with $c_l = \apply{L, \vec k, \vec c, a}$ and $c_r = \apply{R,\vec l,
    \vec d, b})$.
\end{theorem}

\begin{proof}
  Given a logical table instantiation $\tau_l$ and a concrete table
  instantiation $\tau_r$, such that
  $\wp_{\tau_l}(c_l, \pkt = \pkt') \Leftrightarrow \wp_{\tau_r}(c_l,
  \pkt = \pkt')$ and an addition $\rho$ to table $L$, we need to show that
  \[\wp_{\tau_l + \rho}(\apply{L, \vec k, \vec c, a}, \pkt = \pkt') \Leftrightarrow
    \wp_{\tau_r + f^c(\rho)}(\apply{R, \vec l, \vec c, b}, \pkt = \pkt').\]

  We will (equivalently) show that given
  $\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l} =
  \bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r}$, we can prove
  \[\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l + \rho} =
    \bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r + f^c(\rho)}.\]

  Let $\rho = (+, L, \vec v, i)$, and $f^c(\rho) = (+, R, \vec u, j)$,
  such that $h_{i,j} = \TRUE$ and $\vec u = f_{i,j}(\vec v)$.

  Let $\pkt$ be a packet, then we have two cases,
  $\bracbb{\vec k = \vec v}\;\pkt$ is $\TRUE$, or it is $\FALSE$.
  
  First assume that it is $\FALSE$. Then by definition,
  $\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l + \rho}\;\pkt =
  \bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l}\; \pkt$. Since
  $h_{i,j} = 1$, the \textsc{Discernable} condition implies that
  $\bracbb{\vec l = \vec u} = \FALSE$ also, so by definitions we
  compute
  $\bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r + f^c(\rho)}\; \pkt =
  \bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r}\; \pkt$. This case is
  finished by the \textsc{EditSynth} assumption.

  Now assume that $\bracbb{\vec k = \vec v}\;\pkt = \TRUE$. Then, we
  reduce
  $\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l + \rho}\;\pkt =
  \bracbb{c_i}\;\pkt$, and similarly,
  $\bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r + f^c(\rho)}\; \pkt =
  \bracbb{d_j}\; \pkt$. Then, the result follows by \textsc{Implementable}.


\end{proof}


We can also produce the other direction of this theorem.

\begin{theorem}
  Given a solution $f$ to $\textsc{EditSynth}$ where
  $c_l = \apply{L, \vec k, \vec c, a}$ and
  $c_r = \apply{R,\vec l, \vec d, b})$, then we can construct an $f^c$
  that is consistent.
\end{theorem}

\begin{proof}
  Given $f$ such that for every $\tau_l, \tau_r, \rho$,
  \[\wp_{\tau_l}(\apply{L, \vec k, \vec c, a}, \pkt = \pkt') \Leftrightarrow
    \wp_{\tau_r}( \apply{R,\vec l, \vec d, b}, \pkt = \pkt')\]
  implies that
  \[\wp_{\tau_r + \rho}(\apply{L, \vec k, \vec c, a}, \pkt = \pkt') \Leftrightarrow
    \wp_{\tau_l + \sum f(\rho)}(\apply{R,\vec l, \vec d, b}, \pkt = \pkt')\]

  We can equivalently say that forall $\pkt$
    \[\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_l}~\pkt =
    \bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_r}~\pkt\]
  implies that
  \[\bracbb{\apply{L, \vec k, \vec c, a}}_{\tau_r + \rho}~\pkt =
    \bracbb{\apply{R,\vec l, \vec d, b}}_{\tau_l + \sum f(\rho)}~\pkt\]

  Assume there exists

\end{proof}




\subsection{Generalizing : Converting a network program into a single table}

\begin{figure}[pt]
  \[\begin{array}{l >{\triangleq}c l}
      \tablify {x := e} && \apply{\textsf{fresh s}, \cdot, \{x := e\}^*} \\
      \tablify {\assume b} && \apply{\textsf{fresh s}, \cdot, \{\assume b\}^*} \\
      \tablify {\assert b} && \apply{\textsf{fresh s}, \cdot, \{\assert b\}^*} \\
      \tablify {\apply{s, \vec k, \vec c, c_d}} && \apply{s, \vec k, \vec c, c_d} \\
      \tablify {c \angel c'} && \tablify c \diamond \tablify{c'} \\
      \tablify {c ; c'} && \tablify c \circ \tablify{c'}\
    \end{array}\]
  \[
    \begin{array}l
      \apply{s,\vec k, \vec c, a} \circ \apply{t, \vec m, \vec d, b} \\
      \triangleq \apply{st, (\vec x, \vec m), \textsf{map}\; (;)\; (\vec c \times \vec d), a|\vec c| + b}
    \end{array}
  \]
  \[
    \begin{array}l
      \apply{st,\vec k, \vec c, a} \diamond \apply{t, \vec m, \vec d, b} \\
      \triangleq \apply{st, (\vec x, \vec m), \textsf{map}\; (\angel)\; (\vec c \times \vec d), a|\vec c| + b}
    \end{array}
  \]
  
  \caption{Table-normalization function. We star actions as a
    shorthand to denote the default action. The definition of
    $(\circ)$ treats $a$ and $b$ as indices into the vectors $\vec c$
    and $\vec d$. Union on vectors is a uniquifying
    concatenation. $(\times)$ is the cartesian product on vectors, and
    \textsf{map} treats vectors as lists. }
  \label{fig:tablify}
\end{figure}

We can convert a general program into a disjunction of tables using
the function $\tablify c \in \Cmd$, which is defined in
Figure~\ref{fig:tablify}. Assuming the disjunction is deterministic,
our analysis on single tables stands. In fact, allowing disjunctions
makes it easy to compute the functional dependency relation
$(\longrightarrow)$; now $\vec k \longrightarrow c$ in a program $\Angel_{t_i}t_i$,
where each $t_i$ is a table, if there exists a table $t_i$ such that
$\keys{t_i} = \vec k$ and $c \in \actions{t_i}$.

We can also show that for a $c$-complete instantiation function $\tau$
there is always an equivalent instantiation $\tau_t$ for $\tablify c$
(Lemma~\ref{lem:tablifiedinst}), and vice versa
(Lemma~\ref{lem:pretablifiedinst}).

\begin{lemma}
  \label{lem:tablifiedinst}
  For every command $c$ and complete instantiation $\tau$, there
  exists $\tau_t$ such that
  $\bracbb{c}_\tau = \bracbb{\tablify c}_{\tau_t}$.
\end{lemma}

\begin{proof}[Proof Idea]
  Proceed by induction on the structure of $c$:
  \begin{enumerate}[align=left]
  \item[($\apply{s, \vec k, \vec c, a}$)] Immediate.
  \item[($x := e$)] $\bracbb{\tablify {x := e}}_{\langle \rangle} = \bracbb{\apply{t,\cdot, \{x := e\}^*}}_{\langle \rangle} = \bracbb{x:=e}_{\langle \rangle} = \bracbb{x:=e}_{\tau}$.
  \item[($\assert b$)] \textit{sim.}
  \item[($\assume b$)] \textit{sim.}
  \item[($c;c'$)] Our IHs give us $\tau_t$ and $\tau_t'$ such that
    $\bracbb{c}_\tau = \bracbb{\tablify c }_{\tau_t}$ and
    $\bracbb{c'}_\tau = \bracbb{\tablify {c'}}_{\tau_t'}$. Let
    $\apply{s, \vec k, \vec c, d} = \tablify c$, and
    $\apply{s', \vec{k'}, \vec{c'}, d'} = \tablify {c'}$.

    In this limited context $\tau_t$ is a sequence of additions to a
single table: $(e_1,a_1), \ldots, (e_n, a_n)$, and similarly $\tau_t'$
is $(e_1', a_1), \ldots, (e_m', a_m')$.

    We include the row $((e_i,e'_j), (a_i,a_j))$ if $e_1, e_n$
    satisfies the test $\wp(c_{a_i}, \fvs(c_{a_i}) = \vec k')$.

    This proves our goal, since a packet will take rule
    $((e_i,e'_j), (a_i,a_j))$ iff $e_i = \vec{k}$ and
    $\bracbb{c_{a_i}}\; e_j' = \vec{k'}$ by the relationship between
    the semantics and weakest preconditions.
    
  \item[($c \angel c'$)] Our IHs give us $\tau_t$ and $\tau_t'$ such
    that $\bracbb{c}_\tau = \bracbb{\tablify c }_{\tau_t}$ and
    $\bracbb{c'}_\tau = \bracbb{\tablify {c'}}_{\tau_t'}$. Let
    $\apply{s, \vec k, \vec c, d} = \tablify c$, and
    $\apply{s', \vec{k'}, \vec{c'}, d'} = \tablify {c'}$.

    For each row $(\vec e, i) \in \tau_t$ we insert temporary rules
    $(\vec e\vec{\ast'}, i \angel \star)$. Similarly, for every
    $(\vec {e'}, j) \in \tau_t$ we insert temporary row
    $(\vec \ast \vec{e'}, \star \angel j)$. Where the $\ast$ variables
    are unification placeholders. Then, for every pair
    $(\vec e\vec{\ast'}, i \angel \star')$, and $(\vec \ast \vec{e'}, \star
    \angel j)$ we insert a rule $(\vec e\vec e', i \angel j)$ if it it
    is satifiable for $\vec k = \vec e$ and for
    $\vec {k'} = \vec {e'}$. Then we create catch-all rules
    elaborating the wildcards $\ast$ and $\ast'$ setting $\star$ to
    $a$ and $\star'$ to $a'$. Call this $\tau^\ast$.

    We know that
    $\bracbb{ c \angel c'}_{\tau} = \bracbb{c}_\tau \cup \bracbb{c'}_\tau
    = \bracbb{\tablify c}_{\tau_t} \cup
    \bracbb{\tablify{c'}}_{\tau_t'}$, so all we need to show is that
    $\bracbb{\tablify{c}}_{\tau_t} \cup
    \bracbb{\tablify{c'}}_{\tau_t'} = \bracbb{\tablify{c \angel
        c'}}_{\tau^\ast}$.

    Let $\pkt$ be a packet. Assume $\pkt$ matches some rule
    $(\vec{e}, i)$ in $\tau_t$ and another rule $(\vec{e'}, j)$ in
    $\tau_t'$. Then,
    $\bracbb{\tablify{c}}_{\tau_t}\; \pkt \cup
    \bracbb{\tablify{c'}}_{\tau_t'}\;\pkt = \bracbb{c_i}\; pkt \cup
    \bracbb{c'_j}\; \pkt$. Similarly, $\tau^\ast$ has a rule
    $(\vec e\vec e', i \angel j)$, so
    $\bracbb{\tablify{c \angel c'}}_{\tau^\ast} = \bracbb{c_i}\; \pkt
\cup \bracbb{c'_j}\;\pkt$, and we're done.

    Now assume that $\pkt$ takes the default rule in $\tau_t$ and in
    $\tau_t'$, then
    $\bracbb{\tablify{c}}_{\tau_t}\; \pkt \cup
    \bracbb{\tablify{c'}}_{\tau_t'}\;\pkt = \bracbb{c_a}\; pkt \cup
    \bracbb{c'_{a'}}\; \pkt$. By construction, $\tau^*$ will also have
    no rule matching $\pkt$, so we will take its default action
    $c_a \angel c_{a'}$, which has the desired semantics, and we're
    done.

    Now, consider the case that $\pkt$ takes a rule $(\vec{e}, i)$ in
    $\tau_t$, and the default action $a'$ in $\tau_t'$. Now,
    $\bracbb{\tablify{c}}_{\tau_t}\; \pkt \cup
    \bracbb{\tablify{c'}}_{\tau_t'}\;\pkt = \bracbb{c_i}\; \pkt \cup
    \bracbb{c'_{a'}}\; \pkt$. By construction, $\tau^\ast$ has a row
    $(\vec{e}\vec{e'}, i \angel a')$ such that $(\vec{e},i)$ is a
    rule, and packets matching $\vec{e'}$ take the default action in
    $\tau_t'$. So,
    $\bracbb{\tablify{c \angel c'}}_{\tau^\ast} = \bracbb{c_i}\; \pkt
    \cup \bracbb{c'_{a'}}\;\pkt$, and we're done.
    
    
  \end{enumerate}
\end{proof}

\begin{lemma}
  \label{lem:pretablifiedinst}
  For every command $c$ and complete instantiation $\tau_t$, there
  exists $\tau$ such that $\bracbb{\tablify c}_{\tau_t} = \bracbb{c}_\tau$.
\end{lemma}

\begin{proof}
Proceed by induction on the structure of $c$.
\begin{enumerate}[align=left]
  \item[($\apply{s, \vec k, \vec c, a}$)] Immediate.
  \item[($x := e$)] $\bracbb{\tablify {x := e}}_{\langle \rangle} = \bracbb{\apply{t,\cdot, \{x := e\}^*}}_{\langle \rangle} = \bracbb{x:=e}_{\langle \rangle} = \bracbb{x:=e}_{\tau}$.
  \item[($\assert b$)] \textit{sim.}
  \item[($\assume b$)] \textit{sim.}

  \item[($c;c'$)] execute action from first table on packet with keys
    as data values, then match becomes corresponding rule.
  \item[($c \angel c'$)] rule projection is lossy, so -- delete rules
    that go to default action.
\end{enumerate}
\end{proof}

These lemmas (which we've proved by providing constructive witnesses)
together let us perform all of our synthesis by analyzing the single
table and converting our updates back into the original program.

\begin{figure}[pt]
  \newcommand{\linedef}[1]{\multicolumn{3}{>{\qquad}l}{#1}}
  \[
    \begin{array}{lcl}
      \oneify(x:=e, \tau)
      &\triangleq& \langle \rangle \\
      \oneify(\assume b, \tau)
      &\triangleq& \langle \rangle \\
      \oneify(\assert b, \tau)
      &\triangleq& \langle \rangle \\
      \oneify(\apply{t, \vec k, \vec c, a}, \tau)
      &\triangleq&  \tau \\
      \oneify(c;c', \tau)
      &\triangleq& \\
      \linedef{\mathit{let}\; \apply{t, \vec k, \vec c, a} = \tablify{c}} \\
      \linedef{\mathit {let}\; \apply{s, \vec l, \vec d, b} = \tablify {c'}} \\
      \linedef{\mathit {forall}\; (\vec{v_i}, a_i) \in \tau(t),\; (\vec{w_j}, b_j) \in \tau(s)} \\
      \linedef{\{ (\vec{v_i}\vec{u},a_i|\vec c| + b_j) \mid }\\
      \linedef{\qquad \vec{k} = \vec{v_i}\wedge \vec{l} = \vec{u} \Rightarrow \wp(c_{a_i}, \vec l = \vec{w_j})) \}} \\
      \oneify(c \angel c', \tau)
      & \triangleq & \\
      \linedef{\mathit{let}\; \apply{t, \vec k, \vec c, a} = \tablify{c}} \\
      \linedef{\mathit{let}\; \apply{s, \vec l, \vec d, b} = \tablify{c'}} \\
      \linedef{\mathit{forall}\; (\vec{v_i}, a_i) \in \tau(t),\; (\vec{w_j}, b_j) \in \tau(s)} \\
      \linedef{\quad \{(\vec{v_i}\vec{w_j}, a_i|\vec c| +  b_i) \mid \vec{v_i} = \vec k \wedge \vec{w_j} = \vec l\; \mathit{is}\; \textsc{Sat}\} }\\
      \linedef{\quad \cup\{ (\vec{v_i}\vec{u},a_i|\vec c| + b) \mid  \vec u \in \textsf{dom}(\vec l)}\\
      \linedef{\quad\qquad \vec{v_i} = \vec k \wedge \vec{w_j} = \vec l\; \mathit{is}\; \textsc{Unsat}\}} \\
      \linedef{\quad \cup\{ (\vec{u}\vec{w_j}, a|\vec c| +  b_j) \mid  \vec u \in \textsf{dom}(\vec l)}\\
      \linedef{\quad\qquad \vec{v_i} = \vec k \wedge \vec{w_j} = \vec l\; \mathit{is}\; \textsc{Unsat}\}} \\
      \end{array}
  \]
  \caption{$\oneify$ is the function that takes an instantiation on many
    table, to an instantiation on one table.}
\end{figure}

\begin{figure}[pt]
  \newcommand{\linedef}[1]{\multicolumn{3}{>{\qquad}l}{#1}}
  \[
    \begin{array}{lcl}
      \manyify(x:=e, \tau)
      &\triangleq& \langle \rangle \\
      \manyify(\assume b, \tau)
      &\triangleq& \langle \rangle \\
      \manyify(\assert b, \tau)
      &\triangleq& \langle \rangle \\
      \manyify(\apply{t, \vec k, \vec c, a}, \tau)
      &\triangleq&  \tau \\
      \manyify(c;c', \tau)
      &\triangleq& \\
      \linedef{\mathit{let}\; \apply{t, \vec k, \vec c, a} = \tablify{c}} \\
      \linedef{\mathit {let}\; \apply{s, \vec l, \vec d, b} = \tablify {c'}} \\
      \linedef{\displaystyle \bigcup_{(\vec{v_i}\vec{w_j},a_i|\vec c| + b_j) \in \tau(ts)}
      \begin{array}{l} \{(t,\vec{v_i},a_i)\} \;\cup \\ \{(s, \vec u, b_j) \mid \vec l = \vec{u}\Rightarrow \wp^{\vee}(c_{a_i}, \vec{l} = \vec{w_j})\}
        \end{array}} \\
      \manyify(c \angel c', \tau)
      & \triangleq & \\
      \linedef{\mathit{let}\; \apply{t, \vec k, \vec c, a} = \tablify{c}} \\
      \linedef{\mathit{let}\; \apply{s, \vec l, \vec d, b} = \tablify{c'}} \\
      \linedef{\displaystyle \bigcup_{(\vec{v_i}\vec{w_j}, a_i|\vec c| + b) \in \tau(ts)} \{(t, \vec{v_i}, a_i)\}\cup \{(s,\vec{w_j}, b_j)\}}
      \end{array}
  \]
  \caption{$\manyify$ is the function that takes an instantiation on many
    table, to an instantiation on one table.}
\end{figure}



\begin{figure}
  \[
    \begin{array}{lcl}
      \simplify(x:=e, \vec k \longrightarrow_d \vec c)
      &\triangleq& \vec k[x \mapsto e] \longrightarrow_d \overrightarrow{x:=e;c} \\
      \simplify(\assume b, \vec k \longrightarrow_d \vec c)
      & \triangleq& \vec k \longrightarrow_d \overrightarrow{\assume b; c}\\
      \simplify(\assert b, \vec k \longrightarrow_d \vec c)
      & \triangleq& \vec k \longrightarrow_d \overrightarrow{\assert b; c}\\
      \simplify(\vec l \longrightarrow_f \vec b, \vec k \longrightarrow_d \vec c)
      &\triangleq& \\
      \simplify(c;c', \vec k \longrightarrow_d \vec c)
      & \triangleq& \simplify(c, \simplify(c', \vec k \longrightarrow_d \vec c)) \\
    \end{array}
  \]

\end{figure}