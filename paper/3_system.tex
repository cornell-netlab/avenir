\section{System}


\begin{figure}[ht]
  \[\begin{array}{l c l l}
      \multicolumn{4}{l}{\textit{Commands}}\\
      c & ::=& \\
        & \mid & x := e & \textsc{Assignment}\\
        & \mid & c;c & \textsc{Sequence} \\
        & \mid & c \angel c & \textsc{Angelic Choice}\\
        & \mid & \assert b & \textsc{Assertions} \\
        & \mid & \assume b & \textsc{Assumptions} \\
        & \mid & \apply t & \textsc{Table Application}\\
      \multicolumn{4}{l}{\textit{Expressions}} \\
      e & ::= & \\
        & \mid & v            & \textsc{BitVector} \\
        & \mid & x            & \textsc{Field} \\
        & \mid & \hole h       & \textsc{Hole} \\
        & \mid & e,e          & \textsc{Concatenation} \\
        & \mid & e \oplus e   & \textsc{Operation} \\
        & &  \multicolumn{2}{l}{\textit{where}\;\; \oplus \in \{+,-,\times, \div\}} \\
      \multicolumn{4}{l}{\textit{Booleans}}\\
      b & ::= & \\
        & \mid & \TRUE & \textsc{Truth} \\
        & \mid & \FALSE & \textsc{Falsity} \\
        & \mid & b \wedge b & \textsc{Conjunction} \\
        & \mid & b \vee b & \textsc{Disjunction} \\
        & \mid & \neg b & \textsc{Negation} \\
        & \mid & e = e & \textsc{Equality} \\
        & \mid & e \in M & \textsc{Membership} \\
      & \multicolumn{2}{l}{Holes} &\multicolumn{1}{l}{\textit{Matches}} \\
      & \multicolumn{2}{l}{\hole h \in \mathsf{Hole}} & \multicolumn{1}{l}{M \in \mathsf{Hole} \cup \mathsf{Var}}\\
      & \multicolumn{2}{l}{\textit{Values}} &  \multicolumn{1}{l}{\textit{Fields}} \\
      & \multicolumn{2}{l}{v \in \mathbbm{2}^+} & \multicolumn{1}{l}{x \in \mathsf{Var}}
    \end{array}\]

  \caption{Syntax of GCL+Tables}
  \label{fig:syntaxgcl}
  
\end{figure}


\begin{figure}[ht]
  \[\begin{array}{l >{\triangleq}c l l >{\triangleq}c l}
      \multicolumn 3 l {\textit{Tables}}  & \multicolumn 3 l {\textit{Names}}\\
      \multicolumn 3 l {t::= (s,\vec e, \vec c, c_d)} & \multicolumn 3 l {s \in \Name}\\
      \multicolumn 6 c {\textit{Accessors}}\\
      \keys t && \vec x &  \default t && c_d \\
      \actions t && \vec c & \name t && s \\\\
 \\
      
    \end{array}\]

  \caption{Tables}
  \label{fig:tables}
\end{figure}

\begin{figure}[ht]
  \[\begin{array}{l >{\triangleq}c l}
      \wp(x:=e, \phi) && \phi[x \mapsto e]\\
      \wp(c;c', \phi) && \wp(c, \wp(c', \phi)) \\
      \wp(c\angel c', \phi) && \wp(c, \phi) \wedge \wp(c',\phi) \\
      \wp(\assert b, \phi) && b \wedge \phi \\
      \wp(\assume b, \phi) && b \Rightarrow \phi \\
      \wp(\apply t, \phi) && \wp(\parenbb t, \phi) \\\\
      
      \wp(c) && \wp(c,\displaystyle \bigwedge_{\substack{v \in \fvs(c) \\ \mathsf{fresh} v'}}
      v = v')
    \end{array}\]
  \caption{Weakest Preconditions}
  \label{fig:wp}
\end{figure}

\begin{figure}[ht]
  \[\begin{array}{l c l}
      \multicolumn{3}{c}{\textit{Configurations}} \\
      \multicolumn 1 r g & ::= & \langle\rangle \\
        & \mid & (e,i)::g \quad i \in \mathbb N \\
      \multicolumn 1 r g & \in & \mathsf{Config}\\
      \multicolumn 3 l {\textit{Table Instantiations} \qquad \tau : \Name \rightharpoonup \mathsf{Config}}\\
      \parenbb{c\; \tau} &\multicolumn 2 l {\in \mathsf{Cmd}} \\
      \parenbb{(x:= e)\; \tau} &\triangleq& x := e \\
      \parenbb{(c;c')\; \tau} &\triangleq& \parenbb{c\; \tau};\parenbb{c\; \tau} \\
      \parenbb{(c\angel c')\; \tau} &\triangleq& \parenbb{c\; \tau} \angel \parenbb{c'\; \tau}\\
      \parenbb{(\assert b)\; \tau} &\triangleq& \assert b \\
      \parenbb{(\assume b)\; \tau} &\triangleq& \assume b \\
      \parenbb{\apply t\; \tau} &\triangleq& \parenbb{t\; \tau(t)}
    \end{array}\]

  \caption{Configurations and Table Instantiations}
  \label{fig:configs}

  
  
\end{figure}


\todo[inline]{describe language~\ref{fig:syntaxGCL} and wp~\ref{fig:wp}}

As shown in Figure~\ref{fig:tables}, a table is a triple
$(s, \vec e, \vec c, c_d)$, where $s$ is the name of the table, the variables
$e_1,\ldots,e_n$ represent the table keys, the commands $c_1,\ldots, c_m$
represent table actions, and $c_d$ represents the default action, note that
$c_d$ need not be equal to any of the other actions. Also notice that we have
omitted any consideration of action data for the time being. This is because
from a theoretical sense, we can remove action data by creating a new action for
each possible parameter. In practice this is infeasible (an action with a single
48 bit argument would elaborate to $2^{48}$ actions), we'll discuss our
optimizations in a later section.

A table $t$ cannot be executed it must have a configuration (even if that
configuration is the empty config). A configuration is a list of pairs
$(\vec e,i)$, which represents the match conditions for action $i$. The empty
configuration specifies that the default action should be executed. A
configuration $g$ is well-formed for a table $t$ if for every element
$(\vec e, i)$ of $g$, $|\vec e| = |\keys t|$, and $i \leq |\actions t|$, and
every $\vec e$ is a literal, i.e. no fields and no holes.

Now we can use the table configurations to convert a table into a core GCL
program, as depicted in Figure~\ref{fig:configs}. Essentially, we angelically
choose between each of the actions $c_i$. However, there are many situations in
which $c_i$ is executed, so we collect a \emph{match-set} $M_i$ of the $\vec e$s
in config $g$ that trigger $c_i$. Precisely, for a configuration $g$, we define
$M_i \triangleq \{ e | (e,j) \in g, i = j\}$. Then we check to see whether the
current keys, indicated by $\keys t$, are in each set $M_i$, and when we find a
match, we execute $c_i$. If we find no match, we have a final catch-all case,
that executes $c_d$. A table-configuration pair is encoded as follows:

\[ \begin{array}{lcl}
     \parenbb{t\; g}
     & \triangleq
     & \assume{\forall i\neq j, \mathsf{disjoint}(M_i,M_j)}; \\
     &&\left( \displaystyle \Angel_{c_i \in \actions t}
        \assume{\left(\keys t \in M_i\right)}; c_i\right)\\
     && \displaystyle \angel \assert{\left(\bigwedge_{c_i \in \actions t} \keys t \not\in M_i\right)}; c_d
   \end{array}
\]

Notice the initial assume condition, which says that for distinct actions $c_i$
and $c_j$, the corresponding match conditions $M_i$ and $M_j$ are disjiont. This
ensures that the tables are deterministic, i.e. only one branch of the angelic
execution will fire.

We can lift configurations to \emph{table instantiations}
$\tau : \Name \to \Config$, which are simply functions that map each table to a
configuration. We say that a table instantiation $\tau$ is $c$-complete if
$\tau$ is defined on $\name t$ for every table $t$ mentioned in the program
$c$. Then, for a program $c$ and a $c$-complete $\tau$, we write
$\parenbb{c\; \tau}$ for the command with all table applications compiled away.

We want to show that our encoding is correct, so we introduce a semantics for
commands $c$ and for $c,\tau$ pairs, and show that
$\bracbb{\parenbb{c\; \tau}} = \bracbb{c\; \tau}$. The semantics for full
programs are given in Figure~\ref{fig:semantics}, but the work is done on
single-tables and single configurations. Figure~\ref{fig:tablesemantics} defines
$\bracbb{t\; g} : \Pkt \to \Pkt$ for a table $t$ and configuration $g$.

\begin{figure}[ht]
  \[\begin{array}{lcl}
      \bracbb{\apply t\; \langle\rangle}\; \pkt
      &\triangleq& \bracbb{\default t\; \emptyset}\; \pkt \\
      \bracbb{\apply t\; (\vec e, i)::g}\; \pkt
      &\triangleq& \begin{cases}
        c_i & \displaystyle \bigwedge_{e_j} \bracbb{k_j}\; \pkt = \bracbb{e_j}\; \pkt \\
        \bracbb{t\; g}\; \pkt & \mathit{otherwise}
      \end{cases}\\
      && \mathit{where}\; t = (s, \vec k, \vec c, c_d)
    \end{array}\]
  \caption{Semantics for a Single Table}
  \label{fig:tablesemantics}
\end{figure}


\begin{figure}[ht]
  \[\begin{array}{lcl}
      \multicolumn 3 l {\bracbb{c\; \tau} : \Pkt \to 2^\Pkt_\bot} \\
      \bracbb{(x:=e)\; \tau}\; \pkt & \triangleq & (1,\pkt[x \mapsto e]) \\
      \bracbb{(c;c')\; \tau}\; \pkt & \triangleq & \bracbb{c'\; \tau}^\dag(\bracbb{c\; \tau}\; pkt) \\
      \bracbb{(c\angel c')\; \tau}\; pkt &\triangleq& \bracbb{c\; \tau} \cup \bracbb{c'\; \tau} \\
      \bracbb{(\assert b)\; \tau}\; \pkt &\triangleq& \begin{cases}
        \{pkt\}   & \bracbb{b}\; \pkt = \TRUE \\
        \emptyset & \mathit{otherwise}
      \end{cases} \\
      \bracbb{(\assume b)\; \tau}\; \pkt &\triangleq& \begin{cases}
        \{pkt\} & \bracbb{b}\; pkt = \TRUE \\
        \bot    & \mathit{otherwise}
      \end{cases} \\
      \bracbb{(\apply t)\; \tau}\; \pkt &\triangleq& \bracbb{\apply t\; \tau(t)}
    \end{array}\]
  
  \caption{Semantics????????}
  \label{fig:semantics}

\end{figure}

Now we can show that our table encoding is sensible:

\begin{proposition}
  For a program $c$ and a $c$-complete table instantiation function $\tau$,
  $\forall \pkt. \bracbb{c\; \tau};\pkt = \bracbb{\parenbb{c\; \tau}\; \tau}\; \pkt$.
\end{proposition}

\begin{proof}
\todo[inline]{Do the Proof, should be straightforward induction.}
\end{proof}


\subsection{Verification and Synthesis Straw Men}

We can use this calculus to construct some verification and synthesis
problems. Broadly we want to take a logical program $c_l$ and a concrete program
$c_r$, relate their respective table instantiations $\tau_l$, and $\tau_r$,
where $\tau_i$ is $c_i$-complete.  We generate our verification conditions using
Dijkstra's weakest precondition semantics, included for completeness in
Figure~\ref{fig:wp}.

The simplest problem is the verification problem \textsc{Verif} where we are
given the table instantiations $\tau_l$ and $\tau_r$, and we want to verify that
$c_l\; \tau_l$ is equivalent to $c_r\; \tau_r$. Since everything is concrete, we
can encode this as a simple \textsc{sat} problem. If the following problem
returns \texttt{unsat}, we conclude $c_l\; \tau_l$ and $c_r\; \tau_l$ are
equivalent.
\[\begin{array}{lcl}
    \text{Given }( c_l\; \tau_l), (c_r\; \tau_r) \\
    \exists \fvs(c_l), \fvs(c_r). \\
    \qquad \neg(wp(c_l\; \tau_l) \iff wp(c_r\; \tau_r))
  \end{array}
\]

One step up, we have the \textsc{OnlineSynth} problem, where only the logical
table instantiation is given, and we must produce a $\tau_r$ satisfying the
\textsc{Verif} condition. If we get \texttt{sat} and a model for $\tau_r$ from
Z3 we conclude success.
\[\begin{array}{lcl}
    \text{Given } c_l\; \tau_l,c_r
    \exists \tau_r.\\
    \forall \fvs(c_l), \fvs(c_r). \\
    \qquad wp(c_l\; \tau_l) \iff wp(c_r\; \tau_r)
  \end{array}
\]

In a real network, this means that every time the
controller changes the logical forwarding state, we must resynthesize the
concrete forwarding state. However, network engineers care very deeply about the
predictability of their networks, and inserting a heuristic shim in the middle
of the network would make it very hard to exert the kind of control that network
engineers rely on.

To ameliorate this problem, we consider the \textsc{OfflineSynth} problem, which
synthesizes a function $f$ from an arbitary logical instantiations $\tau_l$ to a
concrete table instantiation that will implement the same functionality as
$\tau_l$. The offline synthesis succeeds the following formula is \texttt{sat}
and the witness for $f$ is the solution.
\[\begin{array}{l}
    \text{Given } c_l,c_r\\
    \exists f. \forall \tau_l. \forall \fvs(c_l), \fvs(c_r). \\
    \qquad wp(c_l\; \tau_l) \iff wp(c_r\; f(\tau_l))
  \end{array}\]
However this function $f$ is really quite large, and for even trivial
examples causes Z3 to return \texttt{unknown}. So, we need to find a way of
partitioning the \textsc{OfflineSynth} problem into more tractable
components.

\subsection{Edit-Based Synthesis}

Instead of trying to synthesize an arbitrary function from table instantiations
to table instantiations, we reframe the problem to examining only the table
edits, and call it \textsc{EditSynth}. The idea is: given two equivalent
programs, for every edit to a logical table, can we synthesize an equivalent set
of edits to the concrete tables. This means we synthesize (offline!) two
different functions for each table, one for additions and one for
deletions. This works so long as we have a notion of transactions.

\todo[inline]{The following functions and objects need types!}

Formally an edit $\rho$ is a tuple $(\oplus,s,\vec e,i)$, where
$\oplus \in \{+,-\}$, $s$ is the name of the table being edited, and
$(\vec e, i)$ is thr row to add. Then given an table instantiation function
$\tau$, we write $\tau \otimes \rho$ to update $\tau$ with $\rho$. Precisely,
$\tau \otimes (+,t,\vec e, i) = \tau[t \mapsto (e,i)::\tau(t)$, and
$\tau \otimes (-, t, \vec e, i) = \tau[t \mapsto \tau(t) \setminus (e,i)]$ where
$l \setminus (e,i)$ removes all occurences $(e,i)$ from the list $l$.


A solution for \textsc{EditSynth} is a witness $f$ for every table $t$ such that
the following formula is satisfied:
\[\begin{array}{l}
    \text{Given } c_l,c_r, \exists \rho. \\
    \forall \tau_l,\tau_r,\rho. \forall \fvs(c_l), \fvs(c_r). \\
    \qquad \wp(c_l\; \tau_l) \iff wp(c_r\; \tau_l) \\
    \qquad \Rightarrow \wp(c_l\; (\tau_l \otimes \rho)) \iff \wp(c_r\; \tau_r \otimes (f(\rho)))
  \end{array}\]

For now we have only figured out how to address a simpler version of the
problem:

A solution for \textsc{EditSynth'} is a series of actions $\vec{\rho'}$ for every table $t$ such that
the following formula is valid:
\[\begin{array}{l}
    \text{Given } c_l,c_r, \\
    \forall \rho, \tau_r, \tau_l.\, \exists n.\, \exists \hole\rho_1,\ldots,\hole\rho_n. \\ 
    \quad \forall \fvs(c_l), \fvs(c_r). \\
    \qquad \wp(c_l\; \tau_l) \iff wp(c_r\; \tau_l) \\
    \qquad \Rightarrow \wp(c_l\; (\tau_l \otimes \rho)) \iff \wp(c_r\; \tau_r
    \otimes \hole\rho_1 \otimes \cdots \otimes \hole\rho_n )
  \end{array}\]

In practice, we will can even produce problems \textsc{EditSynth}$(\oplus,s)$
where the universal $\rho$ is restricted so that its first two elements are
$\oplus$ and $s$.



\subsection{Defunctionalizing the Problem}

Solvers don't like such high-order logic problems, so we'll describe how to
convert these problems nearly into MSO.

For every problem, we instrument the same concrete program in the same way, but
we will instrument the logical program differently depending on the modification
we are making to it.

\paragraph{Concrete Program \textsc{EditSynth}$(\oplus, t)$}

For every table $t$, insert a set $\hole{\mathit{Del}_t}$, which indicates the
set of rows to be deleted, and further insert a new match set $\hole{M_{t,i}}$
for every action $c_i \in \actions t$. These will be existentially quantified in
the place of $\vec{\hole{\rho}}$.

Concretely, we can define a new translation $\hole{}\parenbb{t\; g}$,
which inserts these existential holes:

\[\begin{array}{lcl}
    \hole\parenbb{t\; g}
    & \triangleq
    & \assume{\forall i\neq j. \textsf{disjoint}(M_i,M_j)}; \\
    && \assume{\forall i\neq j. \textsf{disjoint}(\hole M_i,\hole M_j)};\\
    && \assume{\forall i,j. \textsf{disjoint}(\hole M_i, M_j)} \\
    && \assume{\forall i. \textsf{disjoint}(\hole M_i, \hole{Del})} \\
    && \displaystyle \Angel_{c_i \in \actions t}
       \left(\begin{array}{c}
         \assume{\keys t \in M_i}; \\
         \assume{\keys t \not\in \hole{\mathit{Del}}};\\
         c_i \\
       \end{array}\right)\\
    && \angel \displaystyle \Angel_{c_i \in \actions t}
       \left(\begin{array}{c}
               \assume{\keys t \in \hole{M_i}}; \\
               c_i \\
             \end{array}\right)\\
    && \displaystyle \angel \left(\assume{\bigwedge_{c_i \in \actions t}
       \begin{array}{c}
         \keys t \not\in M_i\\
         \wedge \keys t \not\in \hole M_i
       \end{array}}; c_d\right)
    %    \assume(\keys t \in M_i\right)}; c_i\right)     
\end{array}\]


We can then lift $\hole\parenbb{t\; g}$ to whole programs and table
instantiation functions in the same way we did for $\parenbb{t\; g}$.



\paragraph{Logical Program for \textsc{EditSynth}$(+,s)$}

To solve the \textsc{EditSynth}$(+,x)$, we add a single new rule to the table
$t$. To do this, we produce a (universally-quantified) symbolic match value
$m_i$ key $e_i$. We also need so specify which action we want to take, which is
specified by the index $a$. As above, we replace $\parenbb{t\;g}$ with
$s^+\parenbb{t\; g}$, which is defined as follows:
\[\begin{array}{lcl}
    s^+\parenbb{(s,\vec e, \vec c, c_d) \; g}
    &\triangleq
    & \parenbb{(s,\vec e, \vec c, c_d) \; g} \\
    s^+\parenbb{(s',\vec e, \vec c, c_d) \; g}
    &\triangleq
    & \assume{\forall i\neq j. \mathsf{disjoint}(M_i,M_j)}; \\
    && \assume{\forall i. \hole{\vec e} \not\in M_i};\\
    && \displaystyle \Angel_{c_i}
       \assume{\left(\vec e \in M_i\right)}; c_i\\
    && \displaystyle \angel \assert{\vec e = \vec m}; c_{\hole a}\\
    && \displaystyle \angel \assert{\bigwedge_{c_i} \vec e \not\in M_i}; c_d
\end{array}\]

Now we can synthesize check whether a solution to \textsc{EditSynth}$(+,s)$
exists by validating the following formula. We universally quantify over the new
matches $\vec m$ and action $i$ as well as the existing logical match sets
$M^l_{i,t}$ for each table $t$ in $c_r$, with $c_i \in \actions t$, and the
existing concrete match sets $M^r_{i,t}$ for each table $t$ in $c_l$, with
$c_i \in \actions t$. Then we existentially quantify (these are the holes) over
match sets $\hole{M_{t,i}}$ for each table $t$ and $c_i \in \actions t$, and
deletion sets $\hole{Del_t}$ for each table $t$ in $c_r$

\[\begin{array}{l}
    \text{Given}\; (c_r), (c_l) \\
    \forall \vec m, i.\\
    \quad \forall M^r_{t_1,0},\ldots,M^r_{t_n,n_m}. \\
    \qquad \forall M^l_{t'_1,0}, \ldots M^l_{t'_n,n'_m}. \\
    \qquad \quad \exists \hole{\mathit{Del}_{t'_1}}, \ldots,
    \hole{\mathit{Del}_{t'_n}} \\
    \qquad \quad \exists \hole{M^l_{t'_1,0}},\ldots, \hole{M^l_{t'_n,n'_m}}\\
    \qquad \qquad \forall \fvs(c_r),\fvs(c_l).\\
    \qquad \qquad \quad (\wp(\parenbb{c\; \tau_r}) \Leftrightarrow \wp(\parenbb{c\; \tau_l})) \\
    \qquad \qquad \qquad \Rightarrow (s^+\parenbb{c_l\; \tau_l}) \Leftrightarrow (\hole\parenbb{c_r\; \tau_r}) \\
  \end{array}\]


\paragraph{Logical Program for \textsc{EditSynth}$(-,s)$}

We do a similar thing when we need to remove a row from a table, except we only
have check that each set does not contain the single row. As before, we replace
$\parenbb{t\;g}$ with $s^-\parenbb{t\; g}$, which is defined as follows:
\[\begin{array}{lcl}
    s^-\parenbb{(s,\vec e, \vec c, c_d) \; g}
    &\triangleq
    & \parenbb{(s,\vec e, \vec c, c_d) \; g} \\
    s^-\parenbb{(s',\vec e, \vec c, c_d) \; g}
    &\triangleq
    & \assume{\forall i\neq j. \mathsf{disjoint}(M_i,M_j)}; \\
    && \assume{\exists! i. \hole{\vec e} \in M_i};\\
    && \displaystyle \Angel_{c_i}
       \assume{\left(\vec e \in M_i\wedge \vec e \neq \vec m \right )}; c_i\\
    && \angel \assume{\vec e = \vec m}; c_d \\
    && \displaystyle \angel \assert{\bigwedge_{c_i \in \actions t} \vec e \not\in M_i}; c_d
\end{array}\]

Then the problem is the same as the previous section replacing $s^+$ for $s^-$.

\paragraph{Generalizing to full synthesis}

We can state the problem as a synthesis problem by observing that
$\exists f. \forall \vec x. \phi(\vec x, f(\vec x))$ is a proof of
$\forall \vec x. \exists y. \phi(\vec x, y)$, but this, perhaps, leaves MSO.
