\section{Syntax and Semantics}

Figure~\ref{fig:syntax} depicts the syntax of commands and
actions. Useful syntactic sugar is presented in
Figure~\ref{fig:sugar}. Finally, Figure~\ref{fig:semantics} depicts
their semantics, notice that actions are deterministic and will always
terminate, which means that for every action $a$, and for every packet
$\pkt$, we can write $\bracbb{a}~\pkt = \{\pkt'\}$. For simplicity we
will often omit the curly braces.


\begin{figure}[ht]
  \[\begin{array}{l c l l}
      \multicolumn{4}{l}{\textit{Commands}~~(\Cmd)~~(\Action^*)}\\
      c & ::=& \\
        & \mid & \var x := e & \textsc{Assignment}^*\\
        & \mid & c;c & \textsc{Sequence}^* \\
        & \mid & c \angel c & \textsc{Demonic Choice}\\
        & \mid & \assert b & \textsc{Assertions} \\
        & \mid & \assume b & \textsc{Assumptions} \\
        & \mid & t & \textsc{Table Application}\\
      \multicolumn{4}{l}{\textit{Expressions}~~(\Expr)} \\
      e & ::= & \\
        & \mid & i            & \textsc{Interval} \\
        & \mid & \var x       & \textsc{Field} \\
        % & \mid & e,e          & \textsc{Concatenation} \\
        & \mid & e \oplus e   & \textsc{Operation} \\
        & &  \multicolumn{2}{l}{\textit{where}\;\; \oplus \in \{+,-,\times \}} \\
      \multicolumn{4}{l}{\textit{Interval}~~(\Interval)}\\
      i & ::= & \\
        & \mid & [] & \textsc{Empty} \\
        & \mid & [v, v] & \textsc{Inclusive Interval} \\
      \multicolumn{4}{l}{\textit{Booleans}}\\
      b & ::= & \\
        & \mid & \TRUE & \textsc{Truth} \\
        & \mid & \FALSE & \textsc{Falsity} \\
        & \mid & b \wedge b & \textsc{Conjunction} \\
        & \mid & b \vee b & \textsc{Disjunction} \\
        & \mid & \neg b & \textsc{Negation} \\ 
        & \mid & e = e & \textsc{Equality} \\
      \multicolumn 4 l {\textit{Tables}~~(\Table)}\\
      k & ::= & b : i \mid e : i & \textsc{Table Key} (\KeyCol) \\
      \var a & ::= & \var x : A & \textsc{Table Action} (\ActCol) \\
      t & ::= & (\var x,\vec{k}, \vec{\var a}, \Phi) & \textsc{Table Schema}\\
      R & ::= & \{\overline{(\vec v, \vec a)}\} & \textsc{Table Instance} \\      
      \multicolumn 4 l {\textit{Constraints}}\\
      \Phi & ::= &\{\overline{\phi} \} & \textsc{Constraint Set}\\
      \phi & ::= & \\
        & \mid & b & \textsc{Boolean} \\
        & \mid & b \Rightarrow \phi & \textsc{Material Implication} \\
        & \mid & \vec {\var x} \longrightarrow \vec{\var a} & \textsc{Determines}\\
        & \mid & \bracbb{A}(\vec{\var x}).\vec{\var x} \longrightarrow \vec{\var a}  & \textsc{Ghost Determines} \\[.3em]
      \multicolumn{2}{l}{\textit{Values}} & \textit{Fields} & \textit{Action Set}\\
      \multicolumn{2}{l}{v \in \mathbbm{2}^+} & \var x, \var y, \var f, \var g \in \mathsf{Var} & A \subseteq \Action
    \end{array}\]
  \caption{Syntax of Commands and Actions. The set
    $\Action \subset \Cmd$ is generated by the starred commands and
    $\SKIP$. An interval $[l, h]$ is only well-formed if $l \leq
    h$. Otherwise we write $[]$ to signify the empty interval.}
  \label{fig:syntax}
\end{figure}

\begin{figure}[tp]
  \[\mathsf{wellFormed} : \Table \to 2\]
  \[\begin{array}{rcl}
      \mathsf{wellFormed}(\var x,\vec k,\vec{\var a : A}, \Phi)
      &\triangleq
      & \vec k \longrightarrow \vec{\var a : A} \in \Phi\\
      && \wedge \bigwedge_{[l_i,h_i] = \dom(k_i)} l_i = 0 < h_i \\
      && \wedge \bigwedge_{A_i} A_i \neq \emptyset
    \end{array}\]
  \caption{Well Formedness of tables. $\dom:\Var \to \Interval$ is a
    function that gives the valid range of a given variable. We assume
    this is stored or can be statically looked up by traversing the
    program. }
  \label{ref:well-formed}
\end{figure}
\begin{figure}[ht]
  \[\begin{array}{lcl}
      \ifte b {c_1} {c_2} & \triangleq & \assume b;c_1 \angel \assume {\neg b}; c_2 \\
      \SKIP & \triangleq& \assume \TRUE \\
      \nop & \triangleq & \assert \TRUE
    \end{array}
  \]
  \caption{Syntactic Sugar. A command is called \emph{deterministic
      and total} if it is only constructed from assignment, sequence
    and the above operators. These programs form the set $\DTCmd$}
  \label{fig:sugar}
\end{figure}

% \begin{figure}[ht]
%   \[\begin{array}{l >{\triangleq}c l}
%       \wp(x:=e, \phi) && \phi[x \mapsto e]\\
%       \wp(c;c', \phi) && \wp(c, \wp(c', \phi)) \\
%       \wp(c\angel c', \phi) && \wp(c, \phi) \wedge \wp(c',\phi) \\
%       \wp(\assert b, \phi) && b \wedge \phi \\
%       \wp(\assume b, \phi) && b \Rightarrow \phi \\
%     \end{array}\]
%   \caption{Weakest Preconditions}
%   \label{fig:wp}
% \end{figure}


\begin{figure}[tpb]
  \[\begin{array}{lcl}
      \multicolumn 3 c {\mathit{Packets}~~(\pkt \in \Pkt)} \\
      \pkt
      &::=
      & \{\overline{\var x \mapsto [l,h]}\}
    \end{array}
  \]
  \[\begin{array}{r@{\hspace{0em}}lcl}
      \{\overline{\var x \mapsto [l,h]}\}&[\var x_i \mapsto [u,v]]
      & \triangleq
      & \{\var x_1 \mapsto [l_1,h_1], \ldots,\\
      &&& \phantom{\{}\var x_i \mapsto [u,v], \ldots, \\
      &&& \phantom{\{}\var x_n\mapsto [l_n,h_n]\}\\
      \{\overline{\var x \mapsto [l,h]}\}&.\var x_i
      &\triangleq
      &[l_i, h_i]
    \end{array}
  \]
  \caption{Packets and packet update. We write
    $\pkt[\overline{\var x \mapsto v}]$ to signify a sequence of
  updates $\pkt[\var x_1 \mapsto v_1]\cdots[\var x_n \mapsto v_n]$}
  \label{fig:packets}
\end{figure}
\begin{figure}
  \[\begin{array}{lcl}
      \multicolumn 3 l {\bracbb{c}:: (\Name \to \Instance) \to \Pkt \to 2^\Pkt}\\
      \bracbb{x:=e}~I~\pkt &\triangleq& \{\pkt[x \mapsto \bracbb{e} \pkt]\} \\
      \bracbb{c;c'}~I~\pkt & \triangleq& \displaystyle \bigcup_{\pkt' \in \bracbb{c'}~T~\pkt}\bracbb{c}~T~\pkt' \\
      \bracbb{c\angel c'}~I~\pkt & \triangleq & \bracbb{c}~\vec T~\pkt \cup \bracbb{c'}~T~\pkt\\
      \bracbb{\assert b}~I~\pkt & \triangleq & \begin{cases}
        \bot & \bracbb{b}~\pkt = \emptyset \\
        \bracbb{b}~\pkt & \textrm{otherwise}
      \end{cases} \\
      \bracbb{\assume b}~\pkt & \triangleq &\bracbb{b}~\pkt\\
      \bracbb{(n,\vec{e : i}, \vec{\var a : A}, \Phi)}~I~\pkt &\triangleq & \bracbb{I(n)}^{\vec{e}}~\pkt \\\\
      \bracbb{(\vec v, \vec a)\cup R}^{\vec{e}}~\pkt & \triangleq &
                                                                    \bracbb{\assume{\vec{e = v}}; \vec a}~\pkt \cup \bracbb{R}^{\vec{e}}~\pkt \\
      \bracbb{\vec a}~pkt & \triangleq & \bracbb{a_1;\cdots;\vec a_n}~\pkt\\
    \end{array}
  \]

  \caption{The semantics. $I$ produces instances for tables. For
    actions, we may omit $I$. The semantics for expressions are given
    in Figure~\ref{fig:expr-semantics} and for booleans in
    Figure~\ref{fig:bool-semantics} are omitted for the time being,
    but are the obvious ones.}
  \label{fig:semantics}
\end{figure}


\begin{figure}
  \[\begin{array}{lcl}
      \multicolumn 3 l {\bracbb{e} :: \Pkt \to \Interval}\\
      \bracbb{v}~\pkt &\triangleq& [v,v] \\
      \bracbb{i}~\pkt &\triangleq& i\\
      \bracbb{\var x}~\pkt & \triangleq & \pkt.\var x \\
      \bracbb{e + e'}~\pkt & \triangleq & \bracbb{e}~\pkt \iplus \bracbb{e'}~\pkt \\
      \bracbb{e - e'}~\pkt & \triangleq & \bracbb{e}~\pkt \iminus \bracbb{e'}~\pkt \\
      \bracbb{e \times e'}~\pkt & \triangleq & \bracbb{e}~\pkt \itimes \bracbb{e'}~\pkt\\      
      % \bracbb{e \shl e'}~\pkt & \triangleq & \bracbb{e}~\pkt \ishl \bracbb{e'}~\pkt\\
      % \bracbb{e \shr e'}~\pkt & \triangleq & \bracbb{e}~\pkt \ishr \bracbb{e'}~\pkt\\
    \end{array}
    \]
  \caption{Interval Semantics for arithmetic expressions. The operators on intervals are defined in Figure~\ref{fig:ivaloperators}}
  \label{fig:expr-semantics}
\end{figure}

\begin{figure}
  \[
    \iplus,\iminus,\itimes,\icap,\ilt :: \Interval \times \Interval \to \Interval\]
  \[\begin{array}{lcl}
      {[x,y]} \iplus [w,z] &\triangleq & [x + w, y + z] \\
      {[x,y]} \iminus [w,z] &\triangleq & [x - z, y - w] \\
      {[x,y]} \itimes [w,z] & \triangleq & [x \times w, y \times z] \\
      {[x,y]} \icap [w,z] & \triangleq & \begin{cases}
        [] &y < w\\
        [] &x > z \\
        [\max(x,w), \min(y,z)] &\mathrm{otherwise}
      \end{cases} 
    \end{array}
  \]
  \[\icup :: \Interval \times \Interval\to 2^\Interval\]
  \[[x,y] \icup [w,z] = \begin{cases}
      \{[x,y],[w,z]\} & y < w \\
      \{[\min(x,w), \max(y,z)]\} & \mathit{otherwise}
    \end{cases}\]
    
  
  \[\ineg :: \Interval \to 2^{\Interval}\]
  \[\ineg [x,y] = \{[0,x-1],[y+1,\infty]\} \]
  
  \[\icap :: \Pkt \times \Pkt \to 2^\Pkt\]
  \[\{\overline{\var x \mapsto i}\} \icap \{\overline{\var x \mapsto j}\} \triangleq \{\overline{\var x \mapsto i \icap j}\}\]

  \caption{Interval operations. }
  \label{fig:ivaloperators}
\end{figure}

\begin{figure}
  \[
    \begin{array}{lcl}
      \multicolumn 3 l {\bracbb{b} :: \Pkt \to 2^\Pkt} \\
      \bracbb{1}~\pkt &\triangleq& \{\pkt\}\\
      \bracbb{0}~\pkt & \triangleq & \emptyset \\
      \bracbb{b \wedge b'}~\pkt &\triangleq & \displaystyle \hat{\bigcup_{\substack{\pkt' \in \bracbb{b}~\pkt\\ \pkt'' \in \bracbb{b'}}}} \pkt' \icap \pkt''\\
      \bracbb{b \vee b'}~\pkt & \triangleq & \bracbb{b}~\pkt \cup \bracbb{b'}~\pkt \\
      \bracbb{\neg b}~\pkt & \triangleq & \displaystyle \hat{\bigcup_{\pkt' \in \bracbb{b}~\pkt}}\ineg \pkt'\\
      \bracbb{e = e'}~\pkt & \triangleq & \bracbb{e}~\pkt \icap \bracbb{e'}~\pkt
    \end{array}
  \]
  \caption{Interval Semantics for boolean expressions. Operators are
    defined in Figure~\ref{fig:ivaloperators}}
  \label{fig:expr_semantics}
\end{figure}
