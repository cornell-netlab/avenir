\section{Syntax and Semantics}

Figure~\ref{fig:syntax} depicts the syntax of commands and
actions. Useful syntactic sugar is presented in
Figure~\ref{fig:sugar}. Finally, Figure~\ref{fig:semantics} depicts
their semantics, notice that actions are deterministic and will always
terminate, which means that for every action $a$, and for every packet
$\pkt$, we can write $\bracbb{a}~\pkt = \{\pkt'\}$. For simplicity we
will often omit the curly braces.


\begin{figure}[ht]
  \[\begin{array}{l c l l}
      \multicolumn{4}{l}{\textit{Commands}~~(\Cmd)~~(\Action^*)}\\
      c & ::=& \\
        & \mid & \var x := e & \textsc{Assignment}^*\\
        & \mid & c;c & \textsc{Sequence}^* \\
        & \mid & c \angel c & \textsc{Demonic Choice}\\
        & \mid & \assert b & \textsc{Assertions} \\
        & \mid & \assume b & \textsc{Assumptions} \\
        & \mid & t & \textsc{Table Application}\\
      \multicolumn{4}{l}{\textit{Expressions}~~(\Expr)} \\
      e & ::= & \\
        & \mid & v            & \textsc{BitVector} \\
        & \mid & \var x       & \textsc{Field} \\
        & \mid & e,e          & \textsc{Concatenation} \\
        & \mid & e \oplus e   & \textsc{Operation} \\
        & &  \multicolumn{2}{l}{\textit{where}\;\; \oplus \in \{+,-,\times, \div, \texttt{<<}, \texttt{>>} \}} \\
      \multicolumn{4}{l}{\textit{Bit Vectors}}\\
      v & ::= & \\
        & \mid & \cdot & \textsc{Empty} \\
        & \mid & b,v   & \textsc{Cons} \\
      \multicolumn{4}{l}{\textit{Booleans}}\\
      b & ::= & \\
        & \mid & \TRUE & \textsc{Truth} \\
        & \mid & \FALSE & \textsc{Falsity} \\
        & \mid & b \wedge b & \textsc{Conjunction} \\
        & \mid & b \vee b & \textsc{Disjunction} \\
        & \mid & \neg b & \textsc{Negation} \\ 
        & \mid & e = e & \textsc{Equality} \\
      \multicolumn 4 l {\textit{Tables}~~(\Table)}\\
      t & ::= & (\vec{\var f}, \vec A, \Phi) & \textsc{Table Schema}\\
      R & ::= & \{\overline{(\vec v, \vec a)}\} & \textsc{Table Instance} \\      
      \multicolumn 4 l {\textit{Constraints}}\\
      \Phi & ::= &\{\overline{\phi} \} & \textsc{Constraint Set}\\
      \phi & ::= & \\
        & \mid & b & \textsc{Boolean} \\
        & \mid & \vec {\var x} \longrightarrow \vec A & \textsc{Functional Dependency}\\
        & \mid & \bracbb{A}(\vec{\var x}).\vec{\var x} \longrightarrow \vec A  & \textsc{Semantic FD} \\[.3em]
      \multicolumn{2}{l}{\textit{Values}} & \textit{Fields} & \textit{Action Set}\\
      \multicolumn{2}{l}{v \in \mathbbm{2}^+} & \var x, \var y, \var f, \var g \in \mathsf{Var} & A \subseteq \Action
    \end{array}\]
  \caption{Syntax of Commands and Actions*}
  \label{fig:syntax}
\end{figure}

\begin{figure}[ht]
  \[\begin{array}{lcl}
      \ifte b {c_1} {c_2} & \triangleq & \assume b;c_1 \angel \assume {\neg b}; c_2 \\
      \SKIP & \triangleq& \assume \TRUE \\
      \nop & \triangleq & \assert \TRUE
    \end{array}
  \]
  \caption{Syntactic Sugar. A command is called \emph{deterministic
      and total} if it is only constructed from assignment, sequence
    and the above operators. These programs form the set $\DTCmd$}
  \label{fig:sugar}
\end{figure}

% \begin{figure}[ht]
%   \[\begin{array}{l >{\triangleq}c l}
%       \wp(x:=e, \phi) && \phi[x \mapsto e]\\
%       \wp(c;c', \phi) && \wp(c, \wp(c', \phi)) \\
%       \wp(c\angel c', \phi) && \wp(c, \phi) \wedge \wp(c',\phi) \\
%       \wp(\assert b, \phi) && b \wedge \phi \\
%       \wp(\assume b, \phi) && b \Rightarrow \phi \\
%     \end{array}\]
%   \caption{Weakest Preconditions}
%   \label{fig:wp}
% \end{figure}


\begin{figure}
  \[\pkt :: = \{\overline{\var x \mapsto v}\}\qquad I :: \Name \to \Instance\]
  \[\begin{array}{lcl}
      \bracbb{x:=e}~I~\pkt &\triangleq& \{\pkt[x \mapsto e]\} \\
      \bracbb{c;c'}~I~\pkt & \triangleq& \displaystyle \bigcup_{\pkt' \in \bracbb{c'}~T~\pkt}\bracbb{c}~T~\pkt' \\
      \bracbb{c\angel c'}~I~\pkt & \triangleq & \bracbb{c}~\vec T~\pkt \cup \bracbb{c'}~T~\pkt\\
      \bracbb{\assert b}~I~\pkt & \triangleq & \begin{cases}
        \pkt & \textrm{if}~\bracbb{b}~\pkt = \TRUE \\
        \bot & \textrm{otherwise}
      \end{cases} \\
      \bracbb{\assume b}~\pkt & \triangleq & \begin{cases}
        \pkt & \textrm{if}~\bracbb{b}~\pkt = \TRUE \\
        \emptyset & \textrm{otherwise}
      \end{cases} \\
      \bracbb{(n,\vec{\var f}, \vec A, \Phi)}~I~\pkt &\triangleq & \bracbb{I(n)}^{\vec{\var f}}~\pkt \\\\
      \bracbb{(\vec v, \vec a)\cup R}^{\vec{\var f}}~\pkt & \triangleq & \begin{cases}
        \bracbb{\vec a}~\pkt & \mathrm{if} \pkt.\vec{\var f} = \vec v\\
        \bracbb{R}^{\vec{\var f}}~\pkt& \mathrm{otherwise}
        \end{cases}                                                            
      \\
      \bracbb{\vec a}~pkt & \triangleq & \bracbb{a_1;\cdots;\vec a_n}~\pkt
    \end{array}
  \]

  \caption{The semantics. $I$ produces instances for tables. For
    actions, we may omit $I$. The semantics for expressions and
    booleans are omitted for the time being, but are the obvious
    ones.}
  \label{fig:semantics}
\end{figure}